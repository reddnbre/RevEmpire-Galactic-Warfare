<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="Defend the galaxy in this action-packed space shooter! Upgrade your ship, collect powerups, and battle increasingly difficult waves of enemies.">
    <meta name="keywords" content="space shooter, arcade game, action game, HTML5 game, browser game">
    <title>RevEmpire: Galactic Warfare</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #0a0f24, #1a1f44);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #0a0f24, #1a1f44);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
        }
        
        #spaceBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .stars {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #eee, transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(1px 1px at 130px 80px, rgba(255,255,255,0.6), transparent),
                radial-gradient(2px 2px at 160px 30px, #ddd, transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: twinkle 4s ease-in-out infinite;
        }
        
        .nebula {
            position: absolute;
            left: -50px;
            top: 50px;
            width: 300px;
            height: 400px;
            background: radial-gradient(ellipse at center, 
                rgba(255, 165, 0, 0.3) 0%,
                rgba(255, 69, 0, 0.2) 30%,
                rgba(255, 0, 0, 0.1) 60%,
                transparent 100%);
            border-radius: 50%;
            filter: blur(20px);
            animation: nebulaGlow 6s ease-in-out infinite;
        }
        
        .comet {
            position: absolute;
            right: 50px;
            top: 100px;
            width: 2px;
            height: 100px;
            background: linear-gradient(to bottom, 
                rgba(255, 165, 0, 1) 0%,
                rgba(255, 165, 0, 0.8) 50%,
                transparent 100%);
            transform: rotate(-15deg);
            animation: cometMove 8s linear infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @keyframes nebulaGlow {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        
        @keyframes cometMove {
            0% { transform: rotate(-15deg) translateX(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: rotate(-15deg) translateX(-200px); opacity: 0; }
        }
        
        .title-image {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: auto;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.6));
            z-index: 10;
        }
        
        .spaceship-image {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%) rotate(15deg);
            width: 300px;
            height: auto;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.6));
            animation: shipFloat 3s ease-in-out infinite;
        }
        
        @keyframes shipFloat {
            0%, 100% { transform: translateX(-50%) rotate(15deg) translateY(0px); }
            50% { transform: translateX(-50%) rotate(15deg) translateY(-10px); }
        }
        
        @keyframes engineGlow {
            0% { opacity: 0.8; height: 30px; }
            100% { opacity: 1; height: 35px; }
        }
        
        @keyframes cockpitGlow {
            0% { opacity: 0.8; box-shadow: 0 0 15px rgba(0, 255, 255, 0.8); }
            100% { opacity: 1; box-shadow: 0 0 25px rgba(0, 255, 255, 1); }
        }

        #loadingScreen h1 {
            font-size: 3.5rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 10px rgba(0, 255, 255, 0.5);
            color: #00ffff;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        #loadingScreen h2 {
            font-size: 2rem;
            margin-bottom: 30px;
            text-shadow: 2px 2px 10px rgba(0, 255, 255, 0.5);
            color: #00ffff;
            font-weight: bold;
            letter-spacing: 1px;
        }

        #loadingBarContainer {
            width: 80%;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
            border: 2px solid #00ffff;
        }

        #loadingBar {
            width: 0%;
            height: 100%;
            background: #00ffff;
            animation: fillBar 4s forwards;
        }

        @keyframes fillBar {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        #hintBox {
            margin-top: 20px;
            font-size: 1.2rem;
            text-align: center;
            width: 80%;
            max-width: 500px;
            min-height: 60px;
            padding: 15px;
            background-color: rgba(0, 255, 255, 0.1);
            border-radius: 10px;
            border: 2px solid #00ffff;
            color: #ffffff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 1);
            font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #loadingScreen footer {
            position: absolute;
            bottom: 20px;
            font-size: 0.9rem;
            color: #ccc;
        }

                 #gameCanvas {
             display: block;
             background: #000;
         }

                 #hud {
             position: absolute;
             top: 10px;
             left: 10px;
             z-index: 100;
             font-size: 16px;
             color: white;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
             background: rgba(0, 0, 0, 0.7);
             padding: 15px;
             border-radius: 10px;
             border: 2px solid #00ffff;
             backdrop-filter: blur(5px);
         }

         #hud div {
             margin-bottom: 8px;
             display: flex;
             justify-content: space-between;
             align-items: center;
             min-width: 200px;
         }

         #hud .stat-label {
             color: #00ffff;
             font-weight: bold;
         }

         #hud .stat-value {
             color: #fff;
             text-shadow: 0 0 5px currentColor;
         }

         #hud .health-bar {
            width: 80px;
             height: 8px;
             background: #333;
             border-radius: 4px;
             overflow: hidden;
             margin-left: 10px;
         }

         #hud .health-fill {
             height: 100%;
             background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
             transition: width 0.3s ease;
         }

        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 500;
        }

        #startScreen h1 {
            font-size: 3rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 2rem;
        }

        #startScreen button {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            color: #000;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #startScreen button:hover {
            background: linear-gradient(45deg, #0080ff, #0040ff);
            color: white;
            transform: scale(1.05);
        }

        #shop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        .shop-container {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 3px solid #00ffff;
            border-radius: 20px;
            padding: 20px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        #shop h2 {
            color: #00ffff;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .shop-section {
            margin-bottom: 15px;
            padding: 12px;
            border: 1px solid #00ffff;
            border-radius: 10px;
            background: rgba(0, 255, 255, 0.05);
        }

        .shop-section h3 {
            color: #00ffff;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 3px 0;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .shop-item button {
            background: linear-gradient(45deg, #00ff00, #008000);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            min-width: 80px;
        }

        .shop-item button:hover {
            background: linear-gradient(45deg, #008000, #004000);
        }

        #closeShop {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ff4444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        #closeShop:hover {
            background: #cc0000;
            transform: scale(1.1);
        }
        
        /* Premium Shop Styles */
        #premiumShop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .premium-shop-content {
            background: linear-gradient(45deg, #0a0a1a, #1a1a3a);
            border: 3px solid #00ffff;
            border-radius: 20px;
            padding: 0;
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }
        
        .premium-header {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            color: #000;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00ffff;
        }
        
        .premium-header h2 {
            margin: 0;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .revcoins-display {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .revcoins-icon {
            font-size: 1.5rem;
        }
        
        .close-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .premium-tabs {
            display: flex;
            background: #1a1a2e;
            border-bottom: 2px solid #00ffff;
        }
        
        .tab-btn {
            flex: 1;
            background: #2a2a4a;
            color: white;
            border: none;
            padding: 15px 20px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover {
            background: #3a3a6a;
        }
        
        .tab-btn.active {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            color: #000;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .premium-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .premium-item {
            background: linear-gradient(45deg, #2a2a4a, #3a3a6a);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .premium-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.3);
            border-color: #ffff00;
        }
        
        .premium-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .premium-item:hover::before {
            left: 100%;
        }
        
        .premium-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .premium-item-name {
            font-size: 1.3rem;
            font-weight: bold;
            color: #00ffff;
        }
        
        .premium-item-price {
            background: linear-gradient(45deg, #ffd700, #ffa500);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .premium-item-description {
            color: #ccc;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .premium-item-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .premium-stat {
            background: rgba(0, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            text-align: center;
        }
        
        .premium-buy-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff00, #008000);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .premium-buy-btn:hover {
            background: linear-gradient(45deg, #00cc00, #006600);
            transform: scale(1.05);
        }
        
        .premium-buy-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .premium-footer {
            background: #1a1a2e;
            padding: 20px 30px;
            border-top: 2px solid #00ffff;
            text-align: center;
        }
        
        .premium-footer button {
            background: linear-gradient(45deg, #ffd700, #ffa500);
            color: #000;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 15px;
        }
        
        .premium-note {
            color: #00ffff;
            font-size: 0.9rem;
            margin: 0;
        }
        
        /* Weapon Shop Styles */
        #weaponShop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .weapon-shop-content {
            background: linear-gradient(45deg, #0a0a1a, #1a1a3a);
            border: 3px solid #ff8800;
            border-radius: 20px;
            padding: 0;
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(255, 136, 0, 0.3);
        }
        
        .weapon-shop-header {
            background: linear-gradient(45deg, #ff8800, #ff6600);
            color: #000;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ff8800;
        }
        
        .weapon-shop-header h2 {
            margin: 0;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .coins-display {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .coins-icon {
            font-size: 1.5rem;
        }
        
        .weapon-shop-tabs {
            display: flex;
            background: #1a1a2e;
            border-bottom: 2px solid #ff8800;
        }
        
        .weapon-tab-btn {
            flex: 1;
            background: #2a2a4a;
            color: white;
            border: none;
            padding: 15px 20px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .weapon-tab-btn:hover {
            background: #3a3a6a;
        }
        
        .weapon-tab-btn.active {
            background: linear-gradient(45deg, #ff8800, #ff6600);
            color: #000;
        }
        
        .weapon-tab-content {
            display: none;
            padding: 30px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .weapon-tab-content.active {
            display: block;
        }
        
        .weapon-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .weapon-item {
            background: linear-gradient(45deg, #2a2a4a, #3a3a6a);
            border: 2px solid #ff8800;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .weapon-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 136, 0, 0.3);
            border-color: #ffff00;
        }
        
        .weapon-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .weapon-item-name {
            font-size: 1.3rem;
            font-weight: bold;
            color: #ff8800;
        }
        
        .weapon-item-price {
            background: linear-gradient(45deg, #ffd700, #ffa500);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .weapon-item-description {
            color: #ccc;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .weapon-item-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .weapon-stat {
            background: rgba(255, 136, 0, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            text-align: center;
        }
        
        .weapon-buy-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff00, #008000);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .weapon-buy-btn:hover {
            background: linear-gradient(45deg, #00cc00, #006600);
            transform: scale(1.05);
        }
        
        .weapon-buy-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .weapon-shop-footer {
            background: #1a1a2e;
            padding: 20px 30px;
            border-top: 2px solid #ff8800;
            text-align: center;
        }
        
        .weapon-note {
            color: #ff8800;
            font-size: 0.9rem;
            margin: 0;
        }
        
        /* Shop Tabs */
        .shop-tabs {
            display: flex;
            background: #1a1a2e;
            border-bottom: 2px solid #00ffff;
            margin-bottom: 15px;
        }
        
        .shop-tab-btn {
            flex: 1;
            background: #2a2a4a;
            color: white;
            border: none;
            padding: 12px 15px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .shop-tab-btn:hover {
            background: #3a3a6a;
        }
        
        .shop-tab-btn.active {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            color: #000;
        }
        
        .shop-tab-content {
            display: none;
            max-height: 50vh;
            overflow-y: auto;
        }
        
        .shop-tab-content.active {
            display: block;
        }
        
        .shop-actions {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .shop-actions button {
            background: linear-gradient(45deg, #00ff00, #008000);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .shop-actions button:hover {
            background: linear-gradient(45deg, #00cc00, #006600);
            transform: scale(1.02);
        }
        
        .shop-actions button:nth-child(2) {
            background: linear-gradient(45deg, #ffd700, #ffa500);
            color: #000;
        }
        
        .shop-actions button:nth-child(3) {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            color: #000;
        }
        
        .shop-actions button:nth-child(4) {
            background: linear-gradient(45deg, #ff4444, #cc0000);
        }
        
        /* Mobile and Tablet Responsive Design */
        @media (max-width: 768px) {
            .shop-container {
                padding: 15px;
                max-width: 98vw;
                max-height: 95vh;
            }
            
            #shop h2 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }
            
            .shop-section {
                padding: 10px;
                margin-bottom: 12px;
            }
            
            .shop-section h3 {
                font-size: 1rem;
            }
            
            .shop-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                padding: 10px;
            }
            
            .shop-item button {
                align-self: flex-end;
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .shop-tabs {
                flex-direction: column;
            }
            
            .shop-tab-btn {
                padding: 10px 12px;
                font-size: 0.9rem;
            }
            
            .shop-actions button {
                margin: 5px 0;
                padding: 12px 20px;
                font-size: 1rem;
                width: 100%;
                max-width: 300px;
            }
            
            /* Premium Shop Mobile */
            .premium-shop-content {
                max-width: 98vw;
                max-height: 95vh;
            }
            
            .premium-header {
                padding: 15px 20px;
                flex-direction: column;
                gap: 10px;
            }
            
            .premium-header h2 {
                font-size: 1.5rem;
            }
            
            .revcoins-display {
                font-size: 1rem;
                padding: 8px 15px;
            }
            
            .premium-tabs {
                flex-direction: column;
            }
            
            .tab-btn {
                padding: 12px 15px;
                font-size: 1rem;
            }
            
            .tab-content {
                padding: 20px;
                max-height: 50vh;
            }
            
            .premium-items-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .premium-item {
                padding: 15px;
            }
            
            .premium-item-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .premium-item-stats {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .premium-footer {
                padding: 15px 20px;
            }
            
            .premium-footer button {
                width: 100%;
                padding: 12px 20px;
            }
            
            /* Weapon Shop Mobile */
            .weapon-shop-content {
                max-width: 98vw;
                max-height: 95vh;
            }
            
            .weapon-shop-header {
                padding: 15px 20px;
                flex-direction: column;
                gap: 10px;
            }
            
            .weapon-shop-header h2 {
                font-size: 1.5rem;
            }
            
            .coins-display {
                font-size: 1rem;
                padding: 8px 15px;
            }
            
            .weapon-shop-tabs {
                flex-direction: column;
            }
            
            .weapon-tab-btn {
                padding: 12px 15px;
                font-size: 1rem;
            }
            
            .weapon-tab-content {
                padding: 20px;
                max-height: 50vh;
            }
            
            .weapon-items-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .weapon-item {
                padding: 15px;
            }
            
            .weapon-item-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .weapon-item-stats {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .weapon-shop-footer {
                padding: 15px 20px;
            }
        }
        
        @media (max-width: 480px) {
            .shop-container {
                padding: 10px;
            }
            
            #shop h2 {
                font-size: 1.3rem;
            }
            
            .shop-item {
                font-size: 0.8rem;
            }
            
            .shop-item button {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
            
            .premium-header h2 {
                font-size: 1.3rem;
            }
            
            .premium-item-name {
                font-size: 1.1rem;
            }
            
            .premium-item-description {
                font-size: 0.9rem;
            }
        }
        
        /* Enhanced Mobile Controls */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
        }
        
        .mobile-controls {
            display: flex;
            gap: 30px;
            align-items: flex-end;
        }
        
        .joystick-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(0, 255, 255, 0.1);
            border: 3px solid #00ffff;
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }
        
        .joystick-thumb {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: 2px solid #ffffff;
            border-radius: 50%;
            position: absolute;
            transition: transform 0.1s ease;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }
        
        .joystick-label {
            color: #00ffff;
            font-size: 0.9rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .action-btn {
            padding: 15px 25px;
            background: linear-gradient(45deg, #ff4444, #cc0000);
            border: 2px solid #ff4444;
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(255, 68, 68, 0.3);
        }
        
        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(255, 68, 68, 0.5);
        }
        
        .action-btn:nth-child(2) {
            background: linear-gradient(45deg, #00ff00, #008000);
            border-color: #00ff00;
            box-shadow: 0 4px 8px rgba(0, 255, 0, 0.3);
        }
        
        .action-btn:nth-child(3) {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border-color: #00ffff;
            box-shadow: 0 4px 8px rgba(0, 255, 255, 0.3);
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }
            
            .action-btn {
                padding: 15px 25px;
                font-size: 1.1rem;
            }
        }

        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 30px;
            z-index: 200;
            display: none;
            text-align: center;
        }

        #levelComplete h2 {
            color: #00ff00;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        #levelComplete button {
            background: linear-gradient(45deg, #00ff00, #008000);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            margin: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
        }

        #levelComplete button:hover {
            background: linear-gradient(45deg, #008000, #004000);
            transform: scale(1.05);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff4444;
            border-radius: 15px;
            padding: 30px;
            z-index: 200;
            display: none;
            text-align: center;
        }

        #gameOver h2 {
            color: #ff4444;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        #gameOver button {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            margin: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
        }

        #gameOver button:hover {
            background: linear-gradient(45deg, #cc0000, #880000);
            transform: scale(1.05);
        }

                 @media (max-width: 768px) {
             #hud {
                 font-size: 14px;
                 padding: 10px;
            }
            
            #startScreen h1 {
                font-size: 2rem;
            }
            
            #shop, #levelComplete, #gameOver {
                padding: 20px;
                margin: 10px;
             }
         }
        
        /* Ad Dialog Styles */
        .ad-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .ad-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            color: white;
        }
        
        .ad-rewards {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .ad-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .ad-watch-btn, .ad-skip-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .ad-watch-btn {
            background: #00ff00;
            color: #000;
        }
        
        .ad-skip-btn {
            background: #ff4444;
            color: white;
        }
        
        /* Withdrawal Dialog Styles */
        .withdrawal-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .withdrawal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            color: white;
        }
        
        .wallet-info {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .withdrawal-input {
            margin: 20px 0;
        }
        
        .withdrawal-input label {
            display: block;
            margin-bottom: 10px;
        }
        
        .withdrawal-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #00ffff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
        }
        
        .withdrawal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .withdraw-btn, .cancel-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .withdraw-btn {
            background: #00ff00;
            color: #000;
        }
        
        .cancel-btn {
            background: #ff4444;
            color: white;
        }
        
        #withdrawBtn {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            color: #000;
            font-weight: bold;
            border: 2px solid #00ff00;
        }
        
        #withdrawBtn:disabled {
            background: #666;
            border-color: #666;
            color: #999;
        }
        
        .go-back-btn {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: white;
            border: 2px solid #ff4444;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 15px;
            transition: all 0.3s ease;
        }
        
        .go-back-btn:hover {
            background: linear-gradient(45deg, #cc0000, #990000);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 68, 68, 0.3);
        }
        
        .hangar-currency-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 10px;
            border: 1px solid #00ffff;
        }
        
        .currency-item {
            font-weight: bold;
            color: #fff;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loadingScreen">
            <div id="spaceBackground">
                <div class="stars"></div>
                <div class="nebula"></div>
                <div class="comet"></div>
                <img src="revempiregalacticatext.png" alt="RevEmpire Galactic Warfare" class="title-image">
                <img src="shiprevempiresprite.png" alt="Spaceship" class="spaceship-image">
            </div>
            
            <div id="loadingBarContainer">
                <div id="loadingBar"></div>
            </div>
            
            <div id="hintBox">Loading game tips...</div>
            
            <footer>Made by RevEmpire.Net</footer>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
                 <div id="hud">
            <div><span class="stat-label">Score:</span> <span class="stat-value" id="score">0</span></div>
            <div><span class="stat-label">Wave:</span> <span class="stat-value" id="wave">1</span></div>
             <div><span class="stat-label">HP:</span> <span class="stat-value" id="healthPercent">100%</span>
                <div class="health-bar">
                     <div class="health-fill" id="healthBar" style="width: 100%"></div>
                 </div>
             </div>
             <div><span class="stat-label">Progress:</span> <span class="stat-value" id="progressPercent">0%</span>
                <div class="health-bar">
                     <div class="health-fill" id="waveProgress" style="width: 0%; background: linear-gradient(90deg, #ffff00, #00ff00);"></div>
                 </div>
             </div>
            <div><span class="stat-label">Coins:</span> <span class="stat-value" id="coins">0</span></div>
            <div><span class="stat-label">Empire Coins:</span> <span class="stat-value" id="empireCoins">1000</span></div>
            <div><span class="stat-label">Enemies:</span> <span class="stat-value" id="enemiesLeft">0</span></div>
            <div><span class="stat-label">Loyalty Earnings:</span> <span class="stat-value" id="earnings">$0.00</span></div>
            <div><span class="stat-label">Total Wallet:</span> <span class="stat-value" id="wallet">$0.00</span></div>
            <div><span class="stat-label">RevCoins:</span> <span class="stat-value" id="revCoins">0</span></div>
            <div><span class="stat-label">Revives:</span> <span class="stat-value" id="revives">0/3</span></div>
            <div><span class="stat-label">Combo:</span> <span class="stat-value" id="comboDisplay">x1</span></div>
            <div><span class="stat-label">Sound:</span> <button id="soundToggle" style="background: #00ff00; color: #000; border: none; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">ON</button></div>
         </div>
        
        <div id="startScreen">
            <h1>RevEmpire: Galactic Warfare</h1>
            <p style="color: #00ffff; margin-bottom: 20px; font-size: 1.1em;">Defend the galaxy in this action-packed space shooter!</p>
            
            <button id="startButton">üöÄ START GAME</button>
            <button id="tutorialButton" onclick="showTutorial()">üìñ HOW TO PLAY</button>
            <button id="shopButton">üõí SHOP</button>
            <button id="leaderboardButton" onclick="showLeaderboard()">üèÜ LEADERBOARD</button>
            <button id="statsButton" onclick="showPlayerStats()">üìä MY STATS</button>
        </div>
        
        <div id="shop" style="display: none;">
            <div class="shop-container">
                <h2>üöÄ REVEMPIRE HANGAR üöÄ</h2>
                <div class="hangar-currency-display">
                    <span class="currency-item">üí∞ <span id="hangarCoins">0</span> Coins</span>
                    <span class="currency-item">üíé <span id="hangarRevCoins">0</span> RevCoins</span>
                </div>
                
                <div class="shop-tabs">
                                    <button class="shop-tab-btn active" data-tab="ships">üõ∏ Ships</button>
                <button class="shop-tab-btn" data-tab="shipyard">üîß Shipyard</button>
                <button class="shop-tab-btn" data-tab="powerups">‚ö° Powerups</button>
                <button class="shop-tab-btn" data-tab="inventory">üì¶ Inventory</button>
                </div>
                
                <div id="shipsTab" class="shop-tab-content active">
                    <div class="shop-section">
                        <h3>Available Ships</h3>
                        <div id="shipList"></div>
                        <button class="go-back-btn" onclick="goBackFromShop()">‚Üê Go Back</button>
                    </div>
                </div>
                
                <div id="shipyardTab" class="shop-tab-content">
                    <div class="shop-section">
                        <h3>Repair & Construction</h3>
                        <div id="shipyardList"></div>
                        <button class="go-back-btn" onclick="goBackFromShop()">‚Üê Go Back</button>
                    </div>
                </div>
                
                <div id="powerupsTab" class="shop-tab-content">
                    <div class="shop-section">
                        <h3>Power-ups & Enhancements</h3>
                        <div id="powerupList"></div>
                        <button class="go-back-btn" onclick="goBackFromShop()">‚Üê Go Back</button>
                    </div>
                </div>
                
                <div id="inventoryTab" class="shop-tab-content">
                    <div class="shop-section">
                        <h3>üì¶ Inventory & Equipment</h3>
                        <div id="inventoryList"></div>
                        <button class="go-back-btn" onclick="goBackFromShop()">‚Üê Go Back</button>
                    </div>
                </div>
                
                            <div class="shop-actions">
                <button id="weaponShopButton">üéØ WEAPON SHOP</button>
                <button id="earnRevCoinsButton">üíé EARN REVCOINS</button>
                <button id="premiumShopButton">üíé PREMIUM SHOP</button>
                <button id="speedUpConstructionButton">‚ö° SPEED UP CONSTRUCTION</button>
                <button id="withdrawBtn" onclick="showWithdrawalDialog()">üí≥ Withdraw (Min $5.00)</button>
                <button id="leaderboardShopButton" onclick="showLeaderboard()">üèÜ LEADERBOARD</button>
                <button id="statsShopButton" onclick="showPlayerStats()">üìä MY STATS</button>
                <button id="backToLevelComplete">‚Üê Back to Level Complete</button>
            </div>
            </div>
        </div>
        
        <!-- Weapon Shop Modal -->
        <div id="weaponShop" style="display: none;">
            <div class="weapon-shop-content">
                <div class="weapon-shop-header">
                    <h2>üéØ WEAPON SHOP</h2>
                    <div class="coins-display">
                        <span class="coins-icon">üí∞</span>
                        <span id="weaponShopCoins">0</span> Coins
                    </div>
                    <button id="closeWeaponShop" class="close-btn">√ó</button>
                </div>
                
                <div class="weapon-shop-tabs">
                    <button class="weapon-tab-btn active" data-tab="regular">üî´ Regular Weapons</button>
                    <button class="weapon-tab-btn" data-tab="premium">üíé Premium Weapons</button>
                </div>
                
                <div id="regularWeaponsTab" class="weapon-tab-content active">
                    <div class="weapon-items-grid" id="regularWeaponsList"></div>
                </div>
                
                <div id="premiumWeaponsTab" class="weapon-tab-content">
                    <div class="weapon-items-grid" id="premiumWeaponsList"></div>
                </div>
                
                <div class="weapon-shop-footer">
                    <p class="weapon-note">üí° Weapons can be used in battle with keyboard shortcuts!</p>
                </div>
            </div>
        </div>
        
        <!-- Premium Shop Modal -->
        <div id="premiumShop" style="display: none;">
            <div class="premium-shop-content">
                <div class="premium-header">
                    <h2>üíé PREMIUM SHOP</h2>
                    <div class="revcoins-display">
                        <span class="revcoins-icon">üíé</span>
                        <span id="premiumRevCoins">0</span> RevCoins
                    </div>
                    <button id="closePremiumShop" class="close-btn">√ó</button>
                </div>
                
                <div class="premium-tabs">
                    <button class="tab-btn active" data-tab="weapons">‚öîÔ∏è Premium Weapons</button>
                    <button class="tab-btn" data-tab="powerups">üõ°Ô∏è Premium Powerups</button>
                </div>
                
                <div id="premiumWeaponsTab" class="tab-content active">
                    <div class="premium-items-grid" id="premiumShopWeaponsList"></div>
                </div>
                
                <div id="premiumPowerupsTab" class="tab-content">
                    <div class="premium-items-grid" id="premiumPowerupsList"></div>
                </div>
                
                <div class="premium-footer">
                    <button id="earnRevCoinsFromPremium">üíé Watch Ad to Earn RevCoins</button>
                    <p class="premium-note">üí° Premium items are superior to regular items and can only be purchased with RevCoins!</p>
                </div>
            </div>
        </div>
        
        <div id="levelComplete">
            <h2>Level Complete!</h2>
            <p>Wave: <span id="completedWave">1</span></p>
            <p>Enemies Defeated: <span id="enemiesDefeated">0</span></p>
            <p>Coins Earned: <span id="coinsEarned">0</span></p>
            <p>Loyalty Earned: <span id="loyaltyEarned">$0.00</span></p>
            
            <div style="margin: 20px 0; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px; border: 1px solid #00ffff;">
                <h3 style="color: #00ffff; margin-bottom: 10px;">üí∞ Double Your Earnings!</h3>
                <p style="margin-bottom: 15px; font-size: 0.9rem;">Watch a short ad to double your coins and loyalty earnings!</p>
                <button id="watchAdForDouble" style="
                    background: linear-gradient(45deg, #ffd700, #ffa500);
                    color: #000;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 5px;
                    font-weight: bold;
                    cursor: pointer;
                    margin-right: 10px;
                ">Watch Ad to Double Earnings</button>
            </div>
            
            <button id="upgradeShips">Ship Shop</button>
            <button id="repairShips">Shipyard</button>
            <button id="buyWeapons">Weapon Shop</button>
            <button id="buyPowerups">Power-ups</button>
            <button id="continueToNextLevel">Continue to Next Level</button>
        </div>
        
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Wave Reached: <span id="finalWave">1</span></p>
            
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 68, 68, 0.1); border-radius: 10px; border: 1px solid #ff4444;">
                <h3 style="color: #ff4444; margin-bottom: 10px;">üõ°Ô∏è Continue Your Mission!</h3>
                <p style="margin-bottom: 15px; font-size: 0.9rem;">Watch an ad to continue with full health and keep all your progress!</p>
                <button id="watchAdForContinue" style="
                    background: linear-gradient(45deg, #00ff00, #008000);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 5px;
                    font-weight: bold;
                    cursor: pointer;
                    margin-right: 10px;
                ">Watch Ad to Continue</button>
        </div>

            <button id="restartGame">Revive</button>
         </div>
    </div>

    <script>
        // ===== GAME VARIABLES =====
        let canvas, ctx;
        let gameRunning = false;
        let gamePaused = false;
        let gameStartTime = Date.now();
        let score = 0;
        let coins = 0;
        let loyalty = 0; // Total lifetime earnings
        let wallet = 0; // Current available balance
        let health = 100;
        let currentWave = 1;
        let enemiesRequiredForLevel = 30;
        let enemiesKilled = 0;
        let enemiesKilledThisWave = 0;
        let coinsEarnedThisWave = 0;
        let loyaltyEarnedThisWave = 0;
        let adWatchedThisWave = false; // Track if ad was watched this wave
        let adBonusAvailable = false; // Track if ad bonus is available
        
        // Player stats
         let empireCoins = 1000;
         let totalWallet = 0;
         let loyaltyEarnings = 0;
        
        // Game objects
        let player = { x: 0, y: 0, width: 40, height: 40, speed: 3, currentShip: 1 };
        let bullets = [];
        let enemies = [];
        let powerups = [];
        let explosions = [];
        let stars = [];
        let seekingMissiles = [];
        let missileExplosions = [];
        
        // Visual effects and feedback
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        let particles = [];
        let comboCount = 0;
        let comboMultiplier = 1;
        let lastKillTime = 0;
        let comboTimeout = 2000; // 2 seconds to maintain combo
        let healthFlash = 0;
        let damageFlash = 0;
        let lowHealthPulse = 0;
        
        // Input
        let keys = {};
        let lastFireTime = 0;
        
        // ===== OBJECT POOLING SYSTEM =====
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 50) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];
                
                // Pre-populate pool
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(this.createFn());
                }
            }
            
            get() {
                if (this.pool.length > 0) {
                    const obj = this.pool.pop();
                    this.active.push(obj);
                    return obj;
                }
                const obj = this.createFn();
                this.active.push(obj);
                return obj;
            }
            
            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    this.resetFn(obj);
                    this.pool.push(obj);
                }
            }
            
            cleanup() {
                this.active.forEach(obj => this.resetFn(obj));
                this.pool.push(...this.active);
                this.active = [];
            }
            
            getActiveCount() {
                return this.active.length;
            }
            
            getPoolSize() {
                return this.pool.length;
            }
        }
        
        // Initialize object pools
        let bulletPool, particlePool, explosionPool;
        
        // ===== ASSET LOADING SYSTEM =====
        class AssetLoader {
            constructor() {
                this.assets = new Map();
                this.loadingPromises = [];
                this.loadedCount = 0;
                this.totalAssets = 0;
                this.fallbackAssets = {
                    'playerShip': 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCI+PHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiBmaWxsPSIjMDBmZmZmIi8+PC9zdmc+',
                    'enemyShip': 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCI+PHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiBmaWxsPSIjZmY0NDQ0Ii8+PC9zdmc+',
                    'powerup': 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCI+PHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjZmZmZjAwIi8+PC9zdmc+'
                };
            }
            
            async loadImage(key, src, fallbackSrc = null) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        this.assets.set(key, img);
                        this.loadedCount++;
                        this.updateLoadingProgress();
                        console.log(`‚úÖ Loaded: ${key}`);
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.warn(`‚ùå Failed to load ${src}, using fallback`);
                        if (fallbackSrc) {
                            img.src = fallbackSrc;
                        } else {
                            img.src = this.fallbackAssets[key] || this.fallbackAssets['playerShip'];
                        }
                        this.assets.set(key, img);
                        this.loadedCount++;
                        this.updateLoadingProgress();
                        resolve(img);
                    };
                    img.src = src;
                });
            }
            
            updateLoadingProgress() {
                const progress = (this.loadedCount / this.totalAssets) * 100;
                const loadingBar = document.getElementById('loadingBar');
                if (loadingBar) {
                    loadingBar.style.width = progress + '%';
                }
                
                // Update hint box with loading status
                const hintBox = document.getElementById('hintBox');
                if (hintBox) {
                    hintBox.textContent = `Loading assets... ${this.loadedCount}/${this.totalAssets} (${Math.round(progress)}%)`;
                }
            }
            
            async loadAll() {
                console.log('üöÄ Starting asset loading...');
                
                const assetList = [
                    // Player ships
                    ['playerShip1', 'assets/Ship_LVL_1.png'],
                    ['playerShip2', 'assets/Ship_LVL_2.png'],
                    ['playerShip3', 'assets/Ship_LVL_3.png'],
                    ['playerShip4', 'assets/Ship_LVL_4.png'],
                    ['playerShip5', 'assets/Ship_LVL_5.png'],
                    
                    // Enemy ships
                    ['enemyFighter', 'assets/Ship_01.png'],
                    ['enemyInterceptor', 'assets/Ship_02.png'],
                    ['enemyDestroyer', 'assets/Ship_03.png'],
                    ['enemyBattleship', 'assets/Ship_04.png'],
                    ['enemyDreadnought', 'assets/Ship_05.png'],
                    ['enemyWarship', 'ChatGPTbattleship1.png'],
                    
                    // Boss ships
                    ['boss1', 'assets/Boss_01.png'],
                    ['boss2', 'assets/Boss_02.png'],
                    ['boss3', 'assets/Boss_03.png'],
                    
                    // Backgrounds
                    ['spaceBackground', 'assets/Space_BG_02.png'],
                    
                    // Powerups
                    ['powerupShield', 'assets/Barrier_Bonus.png'],
                    ['powerupSpeed', 'assets/Hero_Speed_Debuff - Copy.png'],
                    ['powerupDamage', 'Damageicon.png', 'assets/Damage_Bonus.png'],
                    ['powerupRapidFire', 'assets/Rockets_Bonus - Copy.png'],
                    ['powerupMultipleShots', 'assets/Enemy_Destroy_Bonus.png'],
                    ['powerupMagnet', 'assets/Magnet_Bonus - Copy.png'],
                    ['powerupNanobotRepair', 'nanorepairicon.png', 'assets/HP_Bonus.png'],
                    ['powerupDroneAlly', 'assets/drone.png'],
                    ['powerupPiercingLaser', 'piercinglasericon.png', 'assets/Enemy_Speed_Debuff - Copy.png'],
                    ['powerupCoinBoost', 'assets/Armor_Bonus.png'],
                    
                    // Effects
                    ['missileEffect', 'assets/missile.png']
                ];
                
                this.totalAssets = assetList.length;
                
                for (const [key, src, fallbackSrc] of assetList) {
                    this.loadingPromises.push(this.loadImage(key, src, fallbackSrc));
                }
                
                await Promise.all(this.loadingPromises);
                console.log('‚úÖ All assets loaded successfully!');
                
                // Update hint box with completion message
                const hintBox = document.getElementById('hintBox');
                if (hintBox) {
                    hintBox.textContent = 'üéÆ Game ready! Click to start your galactic adventure!';
                }
                
                return true;
            }
            
            get(key) {
                return this.assets.get(key);
            }
            
            isLoaded(key) {
                return this.assets.has(key);
            }
            
            getLoadingProgress() {
                return this.totalAssets > 0 ? (this.loadedCount / this.totalAssets) * 100 : 0;
            }
        }
        
        // Global asset loader instance
        let assetLoader;
        
        // Asset loading function
        async function loadAssetsAsync() {
            try {
                console.log('üöÄ Starting asset loading process...');
                await assetLoader.loadAll();
                
                // Convert loaded assets to sprites format for compatibility
                sprites = {
                    playerShips: {
                        1: assetLoader.get('playerShip1'),
                        2: assetLoader.get('playerShip2'),
                        3: assetLoader.get('playerShip3'),
                        4: assetLoader.get('playerShip4'),
                        5: assetLoader.get('playerShip5')
                    },
                    enemyShips: {
                        fighter: assetLoader.get('enemyFighter'),
                        interceptor: assetLoader.get('enemyInterceptor'),
                        destroyer: assetLoader.get('enemyDestroyer'),
                        battleship: assetLoader.get('enemyBattleship'),
                        dreadnought: assetLoader.get('enemyDreadnought'),
                        warship: assetLoader.get('enemyWarship')
                    },
                    bossShips: {
                        boss1: assetLoader.get('boss1'),
                        boss2: assetLoader.get('boss2'),
                        boss3: assetLoader.get('boss3')
                    },
                    backgrounds: {
                        space: assetLoader.get('spaceBackground')
                    },
                    powerups: {
                        shield: assetLoader.get('powerupShield'),
                        speed: assetLoader.get('powerupSpeed'),
                        damage: assetLoader.get('powerupDamage'),
                        rapidFire: assetLoader.get('powerupRapidFire'),
                        multipleShots: assetLoader.get('powerupMultipleShots'),
                        magnet: assetLoader.get('powerupMagnet'),
                        nanobotRepair: assetLoader.get('powerupNanobotRepair'),
                        droneAlly: assetLoader.get('powerupDroneAlly'),
                        piercingLaser: assetLoader.get('powerupPiercingLaser'),
                        coinBoost: assetLoader.get('powerupCoinBoost')
                    },
                    effects: {
                        missile: assetLoader.get('missileEffect')
                    }
                };
                
                console.log('‚úÖ Assets converted to sprites format');
                
            } catch (error) {
                console.error('‚ùå Asset loading failed:', error);
                // Fallback to old loading method
                loadSprites();
            }
        }
        
        function initializeObjectPools() {
            // Bullet pool
            bulletPool = new ObjectPool(
                () => ({ x: 0, y: 0, width: 4, height: 10, speed: 8, active: false, damage: 20 }),
                (bullet) => {
                    bullet.x = 0;
                    bullet.y = 0;
                    bullet.active = false;
                    bullet.damage = 20;
                },
                100 // Initial pool size
            );
            
            // Particle pool
            particlePool = new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, color: '#fff', type: 'explosion', size: 2, active: false }),
                (particle) => {
                    particle.x = 0;
                    particle.y = 0;
                    particle.vx = 0;
                    particle.vy = 0;
                    particle.life = 0;
                    particle.active = false;
                },
                200 // Initial pool size
            );
            
            // Explosion pool
            explosionPool = new ObjectPool(
                () => ({ x: 0, y: 0, radius: 0, life: 0, maxLife: 0, active: false }),
                (explosion) => {
                    explosion.x = 0;
                    explosion.y = 0;
                    explosion.radius = 0;
                    explosion.life = 0;
                    explosion.active = false;
                },
                50 // Initial pool size
            );
            
            console.log('‚úÖ Object pools initialized');
        }
        
        // Ship data with build times and repair costs
        let ships = {
            1: { 
                name: "Level 1 Starship", 
                price: 500, 
                level: 1, 
                damage: 20, 
                fireRate: 500, 
                speed: 4, 
                health: 100, 
                maxHealth: 100,
                owned: true, 
                destroyed: false, 
                repairCost: 50, 
                buildTime: 0,
                currentBuildTime: 0,
                baseBuildTime: 0 // Level 1 ships are instant
            },
            2: { 
                name: "Level 2 Cruiser", 
                price: 1500, 
                level: 2, 
                damage: 35, 
                fireRate: 450, 
                speed: 5, 
                health: 150, 
                maxHealth: 150,
                owned: false, 
                destroyed: false, 
                repairCost: 75, 
                buildTime: 0,
                currentBuildTime: 0,
                baseBuildTime: 30000 // 30 seconds
            },
            3: { 
                name: "Level 3 Destroyer", 
                price: 4500, 
                level: 3, 
                damage: 50, 
                fireRate: 400, 
                speed: 6, 
                health: 200, 
                maxHealth: 200,
                owned: false, 
                destroyed: false, 
                repairCost: 100, 
                buildTime: 0,
                currentBuildTime: 0,
                baseBuildTime: 60000 // 1 minute
            },
            4: { 
                name: "Level 4 Battleship", 
                price: 13500, 
                level: 4, 
                damage: 70, 
                fireRate: 350, 
                speed: 7, 
                health: 300, 
                maxHealth: 300,
                owned: false, 
                destroyed: false, 
                repairCost: 150, 
                buildTime: 0,
                currentBuildTime: 0,
                baseBuildTime: 120000 // 2 minutes
            },
            5: { 
                name: "Level 5 Dreadnought", 
                price: 40500, 
                level: 5, 
                damage: 100, 
                fireRate: 300, 
                speed: 8, 
                health: 500, 
                maxHealth: 500,
                owned: false, 
                destroyed: false, 
                repairCost: 250, 
                buildTime: 0,
                currentBuildTime: 0,
                baseBuildTime: 300000 // 5 minutes
            }
        };
        
        // Current active ship
        let currentShip = 1;
        
        // Enemy types with AI behaviors
         let enemyTypes = {
             fighter: { 
                 name: "Fighter", 
                 health: 20, 
                 maxHealth: 20,
                 speed: 1.2, 
                 damage: 10, 
                 color: "#ff4444", 
                 weapon: "laser",
                 ai: "straight_shooter", // Shoots straight down
                 fireRate: 2000,
                 lastFireTime: 0,
                 canShoot: false, // Will be enabled based on wave
                 points: 2, // Easy to destroy
                 loyaltyEarning: 0.000001 // Easiest to kill = $0.000001
             },
             interceptor: { 
                 name: "Interceptor", 
                 health: 35, 
                 maxHealth: 35,
                 speed: 1.8, 
                 damage: 15, 
                 color: "#ff8800", 
                 weapon: "plasma",
                 ai: "aimed_shooter", // Shoots toward player
                 fireRate: 2500,
                 lastFireTime: 0,
                 canShoot: false,
                 points: 4, // Medium difficulty, aimed shooter
                 loyaltyEarning: 0.000002 // 2nd easiest to kill = $0.000002
             },
             destroyer: { 
                 name: "Destroyer", 
                 health: 50, 
                 maxHealth: 50,
                 speed: 1.0, 
                 damage: 20, 
                 color: "#ff0080", 
                 weapon: "missile",
                 ai: "kamikaze", // Tries to collide with player
                 fireRate: 3000,
                 lastFireTime: 0,
                 canShoot: false,
                 points: 6, // Harder, kamikaze behavior
                 loyaltyEarning: 0.000003 // Medium difficulty = $0.000003
             },
             battleship: { 
                 name: "Battleship", 
                 health: 80, 
                 maxHealth: 80,
                 speed: 0.6, 
                 damage: 25, 
                 color: "#8000ff", 
                 weapon: "cannon",
                 ai: "straight_shooter",
                 fireRate: 4000,
                 lastFireTime: 0,
                 canShoot: false,
                 points: 8, // High health, slow but dangerous
                 loyaltyEarning: 0.000004 // Harder to kill = $0.000004
             },
             dreadnought: { 
                 name: "Dreadnought", 
                 health: 120, 
                 maxHealth: 120,
                 speed: 0.4, 
                 damage: 30, 
                 color: "#ff0000", 
                 weapon: "quantum",
                 ai: "aimed_shooter",
                 fireRate: 5000,
                 lastFireTime: 0,
                 canShoot: false,
                 points: 10, // Highest difficulty, massive health
                 loyaltyEarning: 0.000005 // Hardest to kill = $0.000005
             },
             warship: { 
                 name: "Warship", 
                 health: 200, 
                 maxHealth: 200,
                 speed: 0.3, 
                 damage: 40, 
                 color: "#8B0000", 
                 weapon: "seeking_missile",
                 ai: "patrol_shooter",
                 fireRate: 4000,
                 lastFireTime: 0,
                 canShoot: true,
                 points: 25, // Mini-boss level points
                 loyaltyEarning: 0.000010, // High reward for difficulty
                 isMiniBoss: true,
                 spawnChance: 0.02 // 2% chance to spawn instead of regular enemy
             }
         };
         
        // Boss types
        let bossTypes = {
            boss1: { 
                name: "Titan Destroyer", 
                health: 500, 
                maxHealth: 500,
                speed: 0.8, 
                damage: 40, 
                color: "#ff0000", 
                weapon: "plasma_cannon",
                sprite: "Boss_01",
                width: 120,
                height: 120,
                fireRate: 2000,
                lastFireTime: 0,
                phase: 1,
                maxPhase: 3,
                phaseHealth: 167, // Health per phase
                specialAttack: "missile_barrage",
                minionSpawnRate: 8000, // Spawn minions every 8 seconds
                lastMinionSpawn: 0,
                reward: { coins: 100, loyalty: 0.00001 }
            },
            boss2: { 
                name: "Void Cruiser", 
                health: 800, 
                maxHealth: 800,
                speed: 0.6, 
                damage: 60, 
                color: "#8000ff", 
                weapon: "void_laser",
                sprite: "Boss_02",
                width: 140,
                height: 140,
                fireRate: 1500,
                lastFireTime: 0,
                phase: 1,
                maxPhase: 4,
                phaseHealth: 200,
                specialAttack: "void_bomb",
                minionSpawnRate: 6000, // Spawn minions every 6 seconds
                lastMinionSpawn: 0,
                reward: { coins: 200, loyalty: 0.00002 }
            },
            boss3: { 
                name: "Omega Battleship", 
                health: 1200, 
                maxHealth: 1200,
                speed: 0.4, 
                damage: 80, 
                color: "#ff00ff", 
                weapon: "omega_cannon",
                sprite: "Boss_03",
                width: 160,
                height: 160,
                fireRate: 1000,
                lastFireTime: 0,
                phase: 1,
                maxPhase: 5,
                phaseHealth: 240,
                specialAttack: "omega_storm",
                minionSpawnRate: 4000, // Spawn minions every 4 seconds
                lastMinionSpawn: 0,
                reward: { coins: 300, loyalty: 0.00003 }
            }
        };
         
        // Powerups
        let powerupsAvailable = {
            shield: { name: "Shield", price: 50, duration: 10000, color: "#00ffff" },
            speed: { name: "Speed Boost", price: 30, duration: 8000, color: "#ffff00" },
            damage: { name: "Damage Boost", price: 40, duration: 12000, color: "#ff0000" },
            rapidFire: { name: "Rapid Fire", price: 60, duration: 15000, color: "#ff8800" },
            multipleShots: { name: "Multiple Shots", price: 80, duration: 12000, color: "#0080ff" },
            magnet: { name: "Magnet", price: 45, duration: 15000, pullRadius: 120, pullStrength: 3, color: "#ffff00" },
            droneAlly: { name: "Drone Ally", price: 70, duration: 20000, fireRate: 600, color: "#8080ff" },
            nanobotRepair: { name: "Nanobot Repair Kit", price: 100, duration: 0, healAmount: 20, color: "#00ff80" },
            piercingLaser: { name: "Piercing Laser", price: 90, duration: 0, shotsRemaining: 10, color: "#ff4080" },
            coinBoost: { name: "Coin Boost", price: 60, duration: 10000, multiplier: 2, color: "#ffcc00" }
        };
        
        let activePowerups = {
            shield: { charges: 0, maxCharges: 5 },
            speed: null,
            damage: null,
            rapidFire: null,
            multipleShots: null,
            magnet: { active: false, endTime: 0, level: 0, pullRadius: 0, pullStrength: 0 },
            droneAlly: null,
            nanobotRepair: null,
            piercingLaser: { active: false, shotsRemaining: 0 },
            coinBoost: null
        };
        
        let droneAlly = null;
        let shipsUnderConstruction = {};
        let levelCompleteMenuShouldBeShown = false;
        let powerEffects = [];
        let powerupMessages = [];
        
        // Premium weapons (superior to regular weapons)
        let premiumWeapons = {
            nuke: { 
                name: "Nuke", 
                price: 50, 
                damage: 800, 
                radius: 300, 
                cooldown: 8000,
                description: "Massive explosion that destroys all enemies in radius"
            },
            quantum: { 
                name: "Quantum Blaster", 
                price: 75, 
                damage: 500, 
                pierce: true, 
                cooldown: 6000,
                description: "Pierces through all enemies with massive damage"
            },
            blackhole: { 
                name: "Black Hole", 
                price: 100, 
                damage: 600, 
                radius: 250, 
                duration: 8000, 
                cooldown: 12000,
                description: "Creates a black hole that sucks in and destroys enemies"
            },
            inferno: { 
                name: "Inferno Cannon", 
                price: 60, 
                damage: 400, 
                burn: true, 
                duration: 5000, 
                cooldown: 10000,
                description: "Sets enemies on fire for continuous damage"
            },
            diamond: { 
                name: "Diamond Laser", 
                price: 90, 
                damage: 1000, 
                pierce: true, 
                cooldown: 15000,
                description: "Ultimate piercing laser with devastating damage"
            }
        };
        
        // Premium powerups (superior to regular powerups)
        let premiumPowerups = {
            megaShield: { 
                name: "Mega Shield", 
                price: 80, 
                duration: 20000, 
                charges: 10,
                description: "Superior shield with 10 charges and longer duration"
            },
            hyperSpeed: { 
                name: "Hyper Speed", 
                price: 70, 
                duration: 15000, 
                multiplier: 3,
                description: "3x speed boost for ultimate maneuverability"
            },
            ultimateDamage: { 
                name: "Ultimate Damage", 
                price: 90, 
                duration: 18000, 
                multiplier: 4,
                description: "4x damage multiplier for devastating attacks"
            },
            infiniteRapidFire: { 
                name: "Infinite Rapid Fire", 
                price: 100, 
                duration: 25000, 
                fireRate: 100,
                description: "Ultra-fast firing rate for maximum destruction"
            },
            superMagnet: { 
                name: "Super Magnet", 
                price: 85, 
                duration: 20000, 
                pullRadius: 300,
                pullStrength: 8,
                description: "Massive magnet that pulls powerups from far away"
            }
        };
        
        // Active premium weapons and powerups
        let activePremiumWeapons = {};
        let activePremiumPowerups = {};
        
        // Inventory system (weapons and premium items)
        let weaponInventory = {
            weapons: {}, // Regular weapons (ship-based)
            premiumWeapons: {}, // Premium weapons
            powerups: {}, // Regular powerups
            premiumPowerups: {} // Premium powerups
        };
        
        // Inventory system with quantity tracking - starts empty, only populated by purchases
        let inventory = {};
        
        // Active powerup tracking - starts at 0 for all powerups
        let activePowerupCounts = {};
        
        // Purchase receipt system
        let purchaseReceipt = {
            items: [],
            totalCoins: 0,
            totalRevCoins: 0
        };
        
        // Leaderboard and Player Stats System
        let playerStats = {
            totalScore: 0,
            totalCoins: 0,
            totalRevCoins: 0,
            totalLoyalty: 0,
            totalWithdrawals: 0,
            highestWave: 1,
            totalEnemiesDestroyed: 0,
            totalBossesDefeated: 0,
            totalPowerupsCollected: 0,
            totalPlayTime: 0,
            gamesPlayed: 0,
            shipsOwned: 0,
            weaponsOwned: 0,
            achievements: [],
            joinDate: Date.now(),
            previousRank: 0,
            currentRank: 0
        };
        
        let leaderboard = [
            { name: "Galactic Emperor", score: 2500000, wave: 50, coins: 150000, achievements: 15 },
            { name: "Star Commander", score: 1800000, wave: 35, coins: 120000, achievements: 12 },
            { name: "Cosmic Warrior", score: 1200000, wave: 28, coins: 95000, achievements: 10 },
            { name: "Space Admiral", score: 800000, wave: 22, coins: 75000, achievements: 8 },
            { name: "Fleet Captain", score: 500000, wave: 18, coins: 60000, achievements: 6 }
        ];
        
        let virtualRewards = {
            1: { title: "üèÜ Galactic Emperor", reward: "100,000 Coins + 1,000 RevCoins", badge: "üëë" },
            2: { title: "ü•à Star Commander", reward: "75,000 Coins + 750 RevCoins", badge: "‚≠ê" },
            3: { title: "ü•â Cosmic Warrior", reward: "50,000 Coins + 500 RevCoins", badge: "‚öîÔ∏è" },
            4: { title: "üéñÔ∏è Space Admiral", reward: "25,000 Coins + 250 RevCoins", badge: "üöÄ" },
            5: { title: "üéØ Fleet Captain", reward: "10,000 Coins + 100 RevCoins", badge: "‚ö°" }
        };
        
        // Ad monetization variables
        let adCooldown = 0;
        let adRewardMultiplier = 2;
        let adWatchCount = 0;
        let adRevenue = 0;
        let reviveCount = 0;
        let maxRevives = 3;
        let revCoins = 0;
        let lastAdWatchTime = 0;
        let adCooldownTime = 5 * 60 * 1000; // 5 minutes in milliseconds
        
        // Boss system variables
        let bossActive = false;
        let currentBoss = null;
        let bossSpawnWave = 5; // Boss spawns every 5 waves
        let bossWarningShown = false;
        let bossWaveCount = 0; // Track how many bosses in current wave
        let maxBossWaves = 1; // Random number of bosses (1-3)
        let bossDefeatedCount = 0; // Track defeated bosses in current wave

        // ===== AUDIO SYSTEM =====
        let audioContext;
        let masterGain;
        let soundEnabled = true;
        
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3; // Master volume
                masterGain.connect(audioContext.destination);
                console.log('‚úÖ Audio system initialized');
            } catch (e) {
                console.log('‚ùå Audio not supported:', e);
                soundEnabled = false;
            }
        }
        
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled || !audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(masterGain);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log('Audio error:', e);
            }
        }
        
        function playShootSound() {
            playSound(800, 0.1, 'square', 0.05);
        }
        
        function playExplosionSound() {
            playSound(100, 0.3, 'sawtooth', 0.1);
            setTimeout(() => playSound(80, 0.2, 'sawtooth', 0.08), 100);
        }
        
        function playPowerupSound() {
            playSound(1200, 0.2, 'sine', 0.08);
            setTimeout(() => playSound(1400, 0.2, 'sine', 0.06), 100);
        }
        
        function playDamageSound() {
            playSound(200, 0.2, 'sawtooth', 0.1);
        }
        
        function playComboSound() {
            playSound(600, 0.1, 'sine', 0.06);
            setTimeout(() => playSound(800, 0.1, 'sine', 0.06), 50);
            setTimeout(() => playSound(1000, 0.1, 'sine', 0.06), 100);
        }
        
        function playWarshipSound() {
            playSound(300, 0.5, 'sawtooth', 0.08);
            setTimeout(() => playSound(250, 0.5, 'sawtooth', 0.08), 200);
        }
        
        function playMissileSound() {
            playSound(400, 0.1, 'triangle', 0.05);
        }
        
        function playMissileExplosionSound() {
            playSound(150, 0.4, 'sawtooth', 0.12);
            setTimeout(() => playSound(120, 0.3, 'sawtooth', 0.1), 150);
        }
        
        function playShieldSound() {
            playSound(1000, 0.2, 'sine', 0.06);
        }
        
        function playCoinSound() {
            playSound(1500, 0.1, 'sine', 0.04);
        }
        
        function playLevelUpSound() {
            playSound(800, 0.1, 'sine', 0.06);
            setTimeout(() => playSound(1000, 0.1, 'sine', 0.06), 100);
            setTimeout(() => playSound(1200, 0.2, 'sine', 0.06), 200);
        }
        
        function playGameOverSound() {
            playSound(200, 0.5, 'sawtooth', 0.15);
            setTimeout(() => playSound(150, 0.5, 'sawtooth', 0.15), 300);
        }
        
        // Quantity selector popup system
        function showQuantitySelector(itemType, itemName) {
            const item = inventory[itemType];
            if (!item || item.owned <= 0) {
                alert('You don\'t have any ' + itemName + ' to use!');
                return;
            }
            
            const currentActive = activePowerupCounts[itemType] || 0;
            const maxToUse = Math.min(item.owned, item.maxActive - currentActive);
            if (maxToUse <= 0) {
                alert('You already have the maximum number of ' + itemName + ' active!');
                return;
            }
            
            // Create popup
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            popup.innerHTML = `
                <div style="
                    background: linear-gradient(45deg, #1a1a2e, #16213e);
                    border: 3px solid #00ffff;
                    border-radius: 15px;
                    padding: 30px;
                    text-align: center;
                    color: white;
                    min-width: 300px;
                ">
                    <h3 style="color: #00ffff; margin-bottom: 20px;">Use ${itemName}</h3>
                    <p style="margin-bottom: 15px;">Owned: ${item.owned} | Active: ${currentActive}/${item.maxActive}</p>
                    
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px;">Quantity to use:</label>
                        <input type="range" id="quantitySlider" min="1" max="${maxToUse}" value="1" style="width: 100%; margin-bottom: 10px;">
                        <span id="quantityDisplay">1</span>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="useButton" style="
                            background: linear-gradient(45deg, #00ff00, #008000);
                            color: white;
                            border: none;
                            padding: 12px 24px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">USE</button>
                        <button id="cancelButton" style="
                            background: linear-gradient(45deg, #ff4444, #cc0000);
                            color: white;
                            border: none;
                            padding: 12px 24px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">CANCEL</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // Add event listeners
            const slider = document.getElementById('quantitySlider');
            const display = document.getElementById('quantityDisplay');
            const useButton = document.getElementById('useButton');
            const cancelButton = document.getElementById('cancelButton');
            
            slider.addEventListener('input', () => {
                display.textContent = slider.value;
            });
            
            useButton.addEventListener('click', () => {
                const quantity = parseInt(slider.value);
                usePowerup(itemType, quantity);
                document.body.removeChild(popup);
            });
            
            cancelButton.addEventListener('click', () => {
                document.body.removeChild(popup);
            });
        }
        
        function usePowerup(itemType, quantity) {
            const item = inventory[itemType];
            if (!item || item.owned < quantity) return;
            
            // Update inventory
            item.owned -= quantity;
            if (!activePowerupCounts[itemType]) {
                activePowerupCounts[itemType] = 0;
            }
            activePowerupCounts[itemType] += quantity;
            
            // Apply powerup effects based on type
            switch(itemType) {
                case 'droneAlly':
                    // Add drones
                    for (let i = 0; i < quantity; i++) {
                        addDroneAlly();
                    }
                    break;
                case 'shield':
                    // Add shield charges
                    activePowerups.shield.charges += quantity;
                    activePowerups.shield.maxCharges += quantity;
                    break;
                case 'speed':
                    // Extend or add speed boost
                    if (activePowerups.speed && Date.now() < activePowerups.speed) {
                        activePowerups.speed += 8000 * quantity; // Extend existing
                    } else {
                        activePowerups.speed = Date.now() + (8000 * quantity);
                    }
                    break;
                case 'damage':
                    // Extend or add damage boost
                    if (activePowerups.damage && Date.now() < activePowerups.damage) {
                        activePowerups.damage += 12000 * quantity; // Extend existing
                    } else {
                        activePowerups.damage = Date.now() + (12000 * quantity);
                    }
                    break;
                case 'rapidFire':
                    // Extend or add rapid fire
                    if (activePowerups.rapidFire && Date.now() < activePowerups.rapidFire) {
                        activePowerups.rapidFire += 15000 * quantity; // Extend existing
                    } else {
                        activePowerups.rapidFire = Date.now() + (15000 * quantity);
                    }
                    break;
                case 'multipleShots':
                    // Extend or add multiple shots
                    if (activePowerups.multipleShots && Date.now() < activePowerups.multipleShots) {
                        activePowerups.multipleShots += 12000 * quantity; // Extend existing
                    } else {
                        activePowerups.multipleShots = Date.now() + (12000 * quantity);
                    }
                    break;
                case 'magnet':
                    // Extend or add magnet
                    if (activePowerups.magnet.active && activePowerups.magnet.endTime > Date.now()) {
                        activePowerups.magnet.endTime += 15000 * quantity; // Extend existing
                        activePowerups.magnet.level += quantity;
                        activePowerups.magnet.pullRadius += 20 * quantity;
                        activePowerups.magnet.pullStrength += 0.5 * quantity;
                    } else {
                        activePowerups.magnet.active = true;
                        activePowerups.magnet.endTime = Date.now() + (15000 * quantity);
                        activePowerups.magnet.level = quantity;
                        activePowerups.magnet.pullRadius = 120 + (20 * quantity);
                        activePowerups.magnet.pullStrength = 3 + (0.5 * quantity);
                    }
                    break;
                case 'nanobotRepair':
                    // Heal player
                    health = Math.min(100, health + (20 * quantity));
                    break;
                case 'piercingLaser':
                    // Add piercing shots
                    activePowerups.piercingLaser.shotsRemaining += 10 * quantity;
                    activePowerups.piercingLaser.active = true;
                    break;
                case 'coinBoost':
                    // Extend or add coin boost
                    if (activePowerups.coinBoost && Date.now() < activePowerups.coinBoost) {
                        activePowerups.coinBoost += 10000 * quantity; // Extend existing
                    } else {
                        activePowerups.coinBoost = Date.now() + (10000 * quantity);
                    }
                    break;
            }
            
            // Show success message
            showRewardMessage(`‚úÖ Used ${quantity} ${itemType}!`);
            playPowerupSound();
            
            // Update shop display
            updateShopDisplay();
        }
        
        function addDroneAlly() {
            // Create a new drone ally
            const drone = {
                x: player.x + player.width + 20,
                y: player.y,
                width: 30,
                height: 30,
                fireRate: 600,
                lastFireTime: Date.now(),
                level: activePowerupCounts.droneAlly + 1
            };
            
            if (!droneAlly) {
                droneAlly = drone;
            } else {
                // If drone already exists, create additional drones as separate entities
                // For now, we'll just enhance the existing drone
                droneAlly.level = activePowerupCounts.droneAlly;
            }
        }
        
        // ===== VISUAL EFFECTS =====
        function addScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }
        
        function createParticles(x, y, count, color, type = 'explosion') {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = 2 + Math.random() * 3;
                const life = 30 + Math.random() * 30;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: life,
                    maxLife: life,
                    color: color,
                    type: type,
                    size: 2 + Math.random() * 3
                });
            }
        }
        
        function createPowerupParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                const speed = 1 + Math.random() * 2;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 60,
                    maxLife: 60,
                    color: color,
                    type: 'powerup',
                    size: 3 + Math.random() * 2
                });
            }
        }
        
        function createComboParticles(x, y) {
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 * i) / 12;
                const speed = 3 + Math.random() * 4;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 45,
                    maxLife: 45,
                    color: color,
                    type: 'combo',
                    size: 2 + Math.random() * 2
                });
            }
        }
        
        function updateCombo() {
            const currentTime = Date.now();
            if (currentTime - lastKillTime > comboTimeout) {
                comboCount = 0;
                comboMultiplier = 1;
            } else {
                comboCount++;
                comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 5));
            }
            lastKillTime = currentTime;
        }
        
        function addHealthFlash() {
            healthFlash = 10;
        }
        
        function addDamageFlash() {
            damageFlash = 15;
        }
        
        function createSeekingMissile(x, y, targetX, targetY) {
            const missile = {
                x: x,
                y: y,
                width: 24, // 2x bigger than before
                height: 40, // 2x bigger than before
                speed: 2,
                maxSpeed: 4,
                turnRate: 0.1,
                targetX: targetX,
                targetY: targetY,
                vx: 0,
                vy: 2,
                life: 300, // 5 seconds max life
                maxLife: 300,
                damage: 30,
                explosionRadius: 80,
                color: '#ff6600',
                trail: []
            };
            seekingMissiles.push(missile);
        }
        
        function updateSeekingMissiles() {
            for (let i = seekingMissiles.length - 1; i >= 0; i--) {
                const missile = seekingMissiles[i];
                
                // Update missile life
                missile.life--;
                if (missile.life <= 0) {
                    // Missile explodes when life runs out
                    createMissileExplosion(missile.x, missile.y, missile.explosionRadius);
                    seekingMissiles.splice(i, 1);
                    continue;
                }
                
                // Update target to current player position
                missile.targetX = player.x + player.width / 2;
                missile.targetY = player.y + player.height / 2;
                
                // Calculate direction to target
                const dx = missile.targetX - missile.x;
                const dy = missile.targetY - missile.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Normalize direction
                    const targetVx = (dx / distance) * missile.maxSpeed;
                    const targetVy = (dy / distance) * missile.maxSpeed;
                    
                    // Gradually turn towards target
                    missile.vx += (targetVx - missile.vx) * missile.turnRate;
                    missile.vy += (targetVy - missile.vy) * missile.turnRate;
                    
                    // Limit speed
                    const currentSpeed = Math.sqrt(missile.vx * missile.vx + missile.vy * missile.vy);
                    if (currentSpeed > missile.maxSpeed) {
                        missile.vx = (missile.vx / currentSpeed) * missile.maxSpeed;
                        missile.vy = (missile.vy / currentSpeed) * missile.maxSpeed;
                    }
                }
                
                // Update position
                missile.x += missile.vx;
                missile.y += missile.vy;
                
                // Add trail effect
                missile.trail.push({ x: missile.x, y: missile.y, life: 10 });
                if (missile.trail.length > 5) {
                    missile.trail.shift();
                }
                
                // Check collision with player
                if (checkCollision(missile, player)) {
                    // Missile hits player
                    if (activePowerups.shield.charges > 0) {
                        activePowerups.shield.charges--;
                        addScreenShake(3, 5);
                        createParticles(player.x + player.width/2, player.y + player.height/2, 8, '#00ffff', 'shield');
                    } else {
                        health -= missile.damage;
                        addDamageFlash();
                        addScreenShake(8, 10);
                        createParticles(player.x + player.width/2, player.y + player.height/2, 12, '#ff0000', 'damage');
                        
                        if (health <= 0) {
                            gameOver();
                        }
                    }
                    
                    // Create explosion
                    createMissileExplosion(missile.x, missile.y, missile.explosionRadius);
                    seekingMissiles.splice(i, 1);
                }
                
                // Remove if off screen
                if (missile.y > canvas.height + 50 || missile.y < -50 || 
                    missile.x > canvas.width + 50 || missile.x < -50) {
                    seekingMissiles.splice(i, 1);
                }
            }
        }
        
        function createMissileExplosion(x, y, radius) {
            // Create explosion particles
            createParticles(x, y, 15, '#ff6600', 'explosion');
            addScreenShake(6, 8);
            playMissileExplosionSound();
            
            // Create explosion effect
            missileExplosions.push({
                x: x,
                y: y,
                radius: radius,
                life: 20,
                maxLife: 20
            });
            
            // Check if player is in explosion radius
            const dx = (player.x + player.width / 2) - x;
            const dy = (player.y + player.height / 2) - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < radius) {
                // Player takes explosion damage
                const damage = Math.floor(20 * (1 - distance / radius)); // Damage decreases with distance
                if (activePowerups.shield.charges > 0) {
                    activePowerups.shield.charges--;
                    addScreenShake(4, 6);
                    createParticles(player.x + player.width/2, player.y + player.height/2, 6, '#00ffff', 'shield');
                } else {
                    health -= damage;
                    addDamageFlash();
                    addScreenShake(6, 8);
                    createParticles(player.x + player.width/2, player.y + player.height/2, 10, '#ff0000', 'damage');
                    
                    if (health <= 0) {
                        gameOver();
                    }
                }
            }
        }
        
        // ===== SPRITE LOADING =====
        let sprites = {
            playerShips: {},
            enemyShips: {},
            backgrounds: {},
            effects: {},
            ui: {}
        };
        
        function loadSprites() {
            console.log('Loading sprites...');
            
            // Initialize sprites object
            sprites = {
                playerShips: {},
                enemyShips: {},
                bossShips: {},
                backgrounds: {},
                effects: {},
                powerups: {},
                ui: {}
            };
            
            // Load player ship sprites
            sprites.playerShips[1] = new Image();
            sprites.playerShips[1].src = 'assets/Ship_LVL_1.png';
            sprites.playerShips[2] = new Image();
            sprites.playerShips[2].src = 'assets/Ship_LVL_2.png';
            sprites.playerShips[3] = new Image();
            sprites.playerShips[3].src = 'assets/Ship_LVL_3.png';
            sprites.playerShips[4] = new Image();
            sprites.playerShips[4].src = 'assets/Ship_LVL_4.png';
            sprites.playerShips[5] = new Image();
            sprites.playerShips[5].src = 'assets/Ship_LVL_5.png';
            
            // Load enemy ship sprites
            sprites.enemyShips.fighter = new Image();
            sprites.enemyShips.fighter.src = 'assets/Ship_01.png';
            sprites.enemyShips.interceptor = new Image();
            sprites.enemyShips.interceptor.src = 'assets/Ship_02.png';
            sprites.enemyShips.destroyer = new Image();
            sprites.enemyShips.destroyer.src = 'assets/Ship_03.png';
            sprites.enemyShips.battleship = new Image();
            sprites.enemyShips.battleship.src = 'assets/Ship_04.png';
            sprites.enemyShips.dreadnought = new Image();
            sprites.enemyShips.dreadnought.src = 'assets/Ship_05.png';
            
            // Load warship sprite
            sprites.enemyShips.warship = new Image();
            sprites.enemyShips.warship.src = 'ChatGPTbattleship1.png';
            
            // Load boss sprites
            sprites.bossShips.boss1 = new Image();
            sprites.bossShips.boss1.src = 'assets/Boss_01.png';
            sprites.bossShips.boss2 = new Image();
            sprites.bossShips.boss2.src = 'assets/Boss_02.png';
            sprites.bossShips.boss3 = new Image();
            sprites.bossShips.boss3.src = 'assets/Boss_03.png';
            
            // Load background
            sprites.backgrounds.space = new Image();
            sprites.backgrounds.space.src = 'assets/Space_BG_02.png';
            
            // Load powerup sprites - each with unique sprite
            sprites.powerups.shield = new Image();
            sprites.powerups.shield.src = 'assets/Barrier_Bonus.png';
            sprites.powerups.shield.onload = () => console.log('‚úÖ Shield sprite loaded');
            sprites.powerups.shield.onerror = () => console.log('‚ùå Shield sprite failed to load');
            
            sprites.powerups.speed = new Image();
            sprites.powerups.speed.src = 'assets/Hero_Speed_Debuff - Copy.png';
            sprites.powerups.speed.onload = () => console.log('‚úÖ Speed sprite loaded');
            sprites.powerups.speed.onerror = () => console.log('‚ùå Speed sprite failed to load');
            
            sprites.powerups.damage = new Image();
            sprites.powerups.damage.src = 'Damageicon.png';
            sprites.powerups.damage.onload = () => console.log('‚úÖ Damage sprite loaded successfully');
            sprites.powerups.damage.onerror = (e) => {
                console.log('‚ùå Damage sprite failed to load:', e);
                console.log('Trying fallback to assets/Damage_Bonus.png...');
                sprites.powerups.damage.src = 'assets/Damage_Bonus.png';
            };
            
            sprites.powerups.rapidFire = new Image();
            sprites.powerups.rapidFire.src = 'assets/Rockets_Bonus - Copy.png';
            sprites.powerups.rapidFire.onload = () => console.log('‚úÖ Rapid Fire sprite loaded');
            sprites.powerups.rapidFire.onerror = () => console.log('‚ùå Rapid Fire sprite failed to load');
            
            sprites.powerups.multipleShots = new Image();
            sprites.powerups.multipleShots.src = 'assets/Enemy_Destroy_Bonus.png'; // Blue skull for multiple shots
            sprites.powerups.multipleShots.onload = () => console.log('‚úÖ Multiple Shots sprite loaded');
            sprites.powerups.multipleShots.onerror = () => console.log('‚ùå Multiple Shots sprite failed to load');
            
            sprites.powerups.magnet = new Image();
            sprites.powerups.magnet.src = 'assets/Magnet_Bonus - Copy.png';
            sprites.powerups.magnet.onload = () => console.log('‚úÖ Magnet sprite loaded');
            sprites.powerups.magnet.onerror = () => console.log('‚ùå Magnet sprite failed to load');
            
            sprites.powerups.nanobotRepair = new Image();
            sprites.powerups.nanobotRepair.src = 'nanorepairicon.png';
            sprites.powerups.nanobotRepair.onload = () => console.log('‚úÖ Nanobot Repair sprite loaded successfully');
            sprites.powerups.nanobotRepair.onerror = (e) => {
                console.log('‚ùå Nanobot Repair sprite failed to load:', e);
                console.log('Trying fallback to assets/HP_Bonus.png...');
                sprites.powerups.nanobotRepair.src = 'assets/HP_Bonus.png';
            };
            
            sprites.powerups.droneAlly = new Image();
            sprites.powerups.droneAlly.src = 'assets/drone.png';
            sprites.powerups.droneAlly.onload = () => console.log('‚úÖ Drone Ally sprite loaded');
            sprites.powerups.droneAlly.onerror = () => console.log('‚ùå Drone Ally sprite failed to load');
            
            sprites.powerups.piercingLaser = new Image();
            sprites.powerups.piercingLaser.src = 'piercinglasericon.png';
            sprites.powerups.piercingLaser.onload = () => console.log('‚úÖ Piercing Laser sprite loaded successfully');
            sprites.powerups.piercingLaser.onerror = (e) => {
                console.log('‚ùå Piercing Laser sprite failed to load:', e);
                console.log('Trying fallback to assets/Enemy_Speed_Debuff - Copy.png...');
                sprites.powerups.piercingLaser.src = 'assets/Enemy_Speed_Debuff - Copy.png';
            };
            
            sprites.powerups.coinBoost = new Image();
            sprites.powerups.coinBoost.src = 'assets/Armor_Bonus.png'; // Golden shield for coin boost
            sprites.powerups.coinBoost.onload = () => console.log('‚úÖ Coin Boost sprite loaded');
            sprites.powerups.coinBoost.onerror = () => console.log('‚ùå Coin Boost sprite failed to load');
            
            // Load missile sprite
            sprites.effects.missile = new Image();
            sprites.effects.missile.src = 'ChatGPTheatseekingmiss.png';
            
            console.log('Sprites loading initiated...');
            
            // Wait a moment for sprites to load, then log status
            setTimeout(() => {
                console.log('=== SPRITE LOADING STATUS ===');
                for (let type in sprites.powerups) {
                    const sprite = sprites.powerups[type];
                    console.log(`${type}: ${sprite.complete ? '‚úÖ Loaded' : '‚ùå Not loaded'} (${sprite.naturalWidth}x${sprite.naturalHeight})`);
                }
                console.log('============================');
            }, 2000);
        }
        
        // ===== INITIALIZATION =====
         function init() {
            console.log('Game initializing...');
            
            // Essential setup first
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Defer heavy operations to prevent load handler violation
            setTimeout(() => {
                // Initialize audio system
                initAudio();
                
                // Check if loading screen exists
                const loadingScreen = document.getElementById('loadingScreen');
                console.log('Loading screen element:', loadingScreen);
                
                // Setup loading screen hints
                setupLoadingHints();
                
                // Initialize and load assets
                assetLoader = new AssetLoader();
                loadAssetsAsync();
                
                // Load player stats from localStorage
                const savedStats = localStorage.getItem('playerStats');
                if (savedStats) {
                    playerStats = JSON.parse(savedStats);
                }
                
                // Update stats with current values
                updatePlayerStats();
                
                // Initialize player position
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - player.height - 50;
                
                // Create stars
                for (let i = 0; i < 100; i++) {
                    stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        speed: Math.random() * 2 + 0.5
                    });
                }
                
                // Setup event listeners
                setupEventListeners();
                
                // Wait for loading animation to complete (12 seconds) then hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    document.getElementById('startScreen').style.display = 'block';
                }, 12000);
                
                console.log('Game initialized successfully!');
            }, 0);
        }
        
        // Loading progress tracking
        function updateLoadingProgress(percent, message) {
            const loadingBar = document.getElementById('loadingBar');
            const hintBox = document.getElementById('hintBox');
            
            if (loadingBar) {
                loadingBar.style.width = percent + '%';
            }
            
            if (hintBox && message) {
                hintBox.innerText = message;
            }
            
            console.log(`Loading: ${percent}% - ${message}`);
        }
        

        
        // Setup cycling hints for loading screen
        function setupLoadingHints() {
            const hints = [
                "üí° Tip: Magnet power-ups stack and increase collection radius.",
                "üõ°Ô∏è Shields block one hit ‚Äî then disappear. Use wisely!",
                "üöÄ Laser upgrades double your firing rate for 10 seconds.",
                "üéØ Power-ups are attracted to you when magnet is active.",
                "ü™ô Collect coins to unlock elite ship skins and bonuses!",
                "üëæ Bosses spawn every 5 levels. Stay sharp!",
                "üìà Higher levels increase enemy speed and power.",
                "‚ö° Boost drops appear after streaks of 20 hits or more.",
                "üéÅ Hidden crates may contain ultra-rare power-ups.",
                "üåå Explore deep space zones beyond wave 25."
            ];

            let index = 0;
            const hintBox = document.getElementById("hintBox");
            
            console.log("Setting up loading hints...");
            console.log("HintBox element:", hintBox);

            function cycleHints() {
                if (hintBox) {
                    hintBox.innerText = hints[index];
                    console.log("Setting hint:", hints[index]);
                    index = (index + 1) % hints.length;
                } else {
                    console.log("HintBox not found!");
                }
            }

            // Cycle hints every 3 seconds
            cycleHints();
            setInterval(cycleHints, 3000);
        }

        // ===== EVENT LISTENERS =====
        function setupEventListeners() {
            // Mobile detection
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Add touch controls for mobile
            if (isMobile) {
                // Touch controls
                canvas.addEventListener('touchstart', handleTouch, { passive: false });
                canvas.addEventListener('touchmove', handleTouch, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                // Prevent default touch behaviors
                canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            }
            
            if (isMobile) {
                setupMobileControls();
            }
            
            function setupMobileControls() {
                // Add enhanced mobile controls
                const mobileControls = document.createElement('div');
                mobileControls.id = 'mobileControls';
                mobileControls.innerHTML = `
                    <div class="mobile-controls">
                        <div class="joystick-container">
                            <div class="joystick-base">
                                <div class="joystick-thumb" id="joystickThumb"></div>
                            </div>
                            <div class="joystick-label">MOVE</div>
                        </div>
                        <div class="action-buttons">
                            <button id="fireBtn" class="action-btn">üî• FIRE</button>
                            <button id="pauseBtn" class="action-btn">‚è∏Ô∏è PAUSE</button>
                            <button id="shopBtn" class="action-btn">üõí SHOP</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(mobileControls);
                
                // Enhanced joystick controls
                setupVirtualJoystick();
                
                // Action button event listeners
                document.getElementById('fireBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.Space = true;
                });
                document.getElementById('fireBtn').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.Space = false;
                });
                
                document.getElementById('pauseBtn').addEventListener('click', (e) => {
                    e.preventDefault();
                    togglePause();
                });
                
                document.getElementById('shopBtn').addEventListener('click', (e) => {
                    e.preventDefault();
                    showShop();
                });
            }
            
            // Virtual joystick system
            function setupVirtualJoystick() {
                const joystickBase = document.querySelector('.joystick-base');
                const joystickThumb = document.getElementById('joystickThumb');
                let isDragging = false;
                let joystickCenter = { x: 0, y: 0 };
                let joystickRadius = 40;
                
                function updateJoystickPosition(clientX, clientY) {
                    const rect = joystickBase.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = clientX - centerX;
                    const deltaY = clientY - centerY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance > joystickRadius) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const thumbX = Math.cos(angle) * joystickRadius;
                        const thumbY = Math.sin(angle) * joystickRadius;
                        joystickThumb.style.transform = `translate(${thumbX}px, ${thumbY}px)`;
                    } else {
                        joystickThumb.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    }
                    
                    // Update movement keys based on joystick position
                    const normalizedX = deltaX / joystickRadius;
                    const normalizedY = deltaY / joystickRadius;
                    
                    keys.ArrowLeft = normalizedX < -0.3;
                    keys.ArrowRight = normalizedX > 0.3;
                    keys.ArrowUp = normalizedY < -0.3;
                    keys.ArrowDown = normalizedY > 0.3;
                }
                
                joystickBase.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
                });
                
                joystickBase.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (isDragging) {
                        updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
                    }
                });
                
                joystickBase.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    isDragging = false;
                    joystickThumb.style.transform = 'translate(0px, 0px)';
                    keys.ArrowLeft = false;
                    keys.ArrowRight = false;
                    keys.ArrowUp = false;
                    keys.ArrowDown = false;
                });
            }
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Mouse movement
            canvas.addEventListener('mousemove', (e) => {
                if (gameRunning && !gamePaused) {
                    const rect = canvas.getBoundingClientRect();
                    player.x = e.clientX - rect.left - player.width / 2;
                    player.y = e.clientY - rect.top - player.height / 2;
                    
                    // Keep player in bounds
                    if (player.x < 0) player.x = 0;
                    if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
                    if (player.y < 0) player.y = 0;
                    if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
                }
            });
            
            // Touch controls for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameRunning || gamePaused) return;
                
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // Move player to touch position
                player.x = x - player.width / 2;
                player.y = y - player.height / 2;
                
                // Keep player on screen
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
                if (player.y < 0) player.y = 0;
                if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
                
                // Auto-fire when touching
                if (Date.now() - lastFireTime > fireRate) {
                    fireBullet();
                    lastFireTime = Date.now();
                }
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!gameRunning || gamePaused) return;
                
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // Move player to touch position
                player.x = x - player.width / 2;
                player.y = y - player.height / 2;
                
                // Keep player on screen
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
                if (player.y < 0) player.y = 0;
                if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
                
                // Auto-fire when touching
                if (Date.now() - lastFireTime > fireRate) {
                    fireBullet();
                    lastFireTime = Date.now();
                }
            }, { passive: false });
            
            // Button events
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('shopButton').addEventListener('click', () => {
                document.getElementById('shop').style.display = 'block';
                updateShopDisplay();
                // Only pause if game is running
                if (gameRunning) {
                    gamePaused = true;
                }
            });
            

            
                            document.getElementById('backToLevelComplete').addEventListener('click', () => {
                    document.getElementById('shop').style.display = 'none';
                    // Only show level complete if we actually completed a level
                    if (levelCompleteMenuShouldBeShown) {
                        document.getElementById('levelComplete').style.display = 'block';
                    } else {
                        // Resume the game if we didn't actually complete a level
                        gamePaused = false;
                        levelCompleteMenuShouldBeShown = false;
                        gameLoop();
                    }
                });
            
            document.getElementById('continueToNextLevel').addEventListener('click', continueToNextLevel);
            document.getElementById('restartGame').addEventListener('click', restartGame);
            
            // Ad monetization event listeners
            document.getElementById('watchAdForDouble').addEventListener('click', showDoubleEarningsAd);
            document.getElementById('watchAdForContinue').addEventListener('click', showContinueAd);
            document.getElementById('earnRevCoinsButton').addEventListener('click', showRevCoinsAd);
            
            // Premium shop event listeners
            document.getElementById('premiumShopButton').addEventListener('click', openPremiumShop);
            document.getElementById('closePremiumShop').addEventListener('click', closePremiumShop);
            document.getElementById('earnRevCoinsFromPremium').addEventListener('click', showRevCoinsAd);
            
            // Weapon shop event listeners
            document.getElementById('weaponShopButton').addEventListener('click', openWeaponShop);
            document.getElementById('closeWeaponShop').addEventListener('click', closeWeaponShop);
            
            // Speed up construction button
            document.getElementById('speedUpConstructionButton').addEventListener('click', showSpeedUpBuildAd);
            
            // Weapon shop tab switching
            document.querySelectorAll('.weapon-tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabName = btn.getAttribute('data-tab');
                    switchWeaponTab(tabName);
                });
            });
            
            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabName = btn.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });
            
            // Shop tab switching
            document.querySelectorAll('.shop-tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabName = btn.getAttribute('data-tab');
                    switchShopTab(tabName);
                });
            });
            
            // Add event listeners for level complete menu buttons
            document.getElementById('upgradeShips').addEventListener('click', () => {
                document.getElementById('levelComplete').style.display = 'none';
                document.getElementById('shop').style.display = 'block';
                updateShopDisplay();
            });
            
            document.getElementById('repairShips').addEventListener('click', () => {
                document.getElementById('levelComplete').style.display = 'none';
                document.getElementById('shop').style.display = 'block';
                updateShopDisplay();
            });
            
            document.getElementById('buyWeapons').addEventListener('click', () => {
                document.getElementById('levelComplete').style.display = 'none';
                document.getElementById('shop').style.display = 'block';
                updateShopDisplay();
            });
            
            document.getElementById('buyPowerups').addEventListener('click', () => {
                document.getElementById('levelComplete').style.display = 'none';
                document.getElementById('shop').style.display = 'block';
                updateShopDisplay();
            });
            
            // Sound toggle
            document.getElementById('soundToggle').addEventListener('click', () => {
                soundEnabled = !soundEnabled;
                const button = document.getElementById('soundToggle');
                if (soundEnabled) {
                    button.textContent = 'ON';
                    button.style.background = '#00ff00';
                    button.style.color = '#000';
                } else {
                    button.textContent = 'OFF';
                    button.style.background = '#ff0000';
                    button.style.color = '#fff';
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // ===== GAME FUNCTIONS =====
                 function startGame() {
            console.log('Starting game...');
            
            // Initialize object pools for better performance
            initializeObjectPools();
            
            document.getElementById('startScreen').style.display = 'none';
            gameStartTime = Date.now(); // Reset game start time
            reviveCount = 0; // Reset revive count for new game
             gameRunning = true;
             gamePaused = false;
             gameLoop();
         }
        
                 function gameLoop() {
             if (!gameRunning || gamePaused) return;
             
             update();
             draw();
             requestAnimationFrame(gameLoop);
         }
        
                         function update() {
            // Update visual effects
            if (screenShake.duration > 0) {
                screenShake.duration--;
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update visual feedback
            if (healthFlash > 0) healthFlash--;
            if (damageFlash > 0) damageFlash--;
            lowHealthPulse = health < 30 ? (lowHealthPulse + 0.2) % (Math.PI * 2) : 0;
            
            // Update player movement
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) player.x += player.speed;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) player.y -= player.speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) player.y += player.speed;
            
            // Keep player in bounds
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
             
             // Auto-fire
             const currentTime = Date.now();
             let fireRate = ships[player.currentShip].fireRate;
             
             if (activePowerups.rapidFire && currentTime < activePowerups.rapidFire) {
                fireRate = Math.max(50, fireRate / 3);
             }
             
             if (currentTime - lastFireTime > fireRate) {
                 fireShipWeapon();
                 playShootSound();
                 lastFireTime = currentTime;
             }
             
            // Spawn enemies continuously until level is complete
            if (enemiesKilledThisWave < enemiesRequiredForLevel) {
                 spawnEnemies();
             }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet based on type
                if (bullet.isEnemyBullet || bullet.isBossBullet) {
                    bullet.x += bullet.vx || 0;
                    bullet.y += bullet.vy || bullet.speed;
                } else {
                    bullet.y -= bullet.speed;
                }
                
                // Remove bullet if off screen
                if (bullet.y < -bullet.height || bullet.y > canvas.height || 
                    bullet.x < -bullet.width || bullet.x > canvas.width) {
                    bullets.splice(i, 1);
                }
                
                // Check enemy bullets hitting player using center mass collision
                if ((bullet.isEnemyBullet || bullet.isBossBullet) && checkCenterMassCollision(bullet, player)) {
                    if (activePowerups.shield.charges > 0) {
                        activePowerups.shield.charges--;
                        bullets.splice(i, 1);
                        // Shield hit effect
                        addScreenShake(2, 3);
                        createParticles(player.x + player.width/2, player.y + player.height/2, 5, '#00ffff', 'shield');
                        playShieldSound();
                    } else {
                        health -= bullet.damage;
                        bullets.splice(i, 1);
                        
                        // Damage visual effects
                        addDamageFlash();
                        addScreenShake(5, 8);
                        createParticles(player.x + player.width/2, player.y + player.height/2, 6, '#ff0000', 'damage');
                        playDamageSound();
                        
                        if (health <= 0) {
                            gameOver();
                        }
                    }
                }
            }
            
            // Update enemies with AI behaviors
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Enable enemy shooting based on wave progression
                if (!enemy.canShoot && currentWave >= 3) {
                    enemy.canShoot = true;
                }
                
                // Enhanced enemy AI behavior that scales with wave level
                const aiIntelligence = Math.min(1.0, currentWave / 10); // Max intelligence at wave 10
                
                switch(enemy.ai) {
                    case 'straight_shooter':
                        // Move straight down with slight evasion
                        enemy.y += enemy.speed;
                        if (aiIntelligence > 0.3) {
                            // Add slight horizontal movement to avoid bullets
                            enemy.x += Math.sin(Date.now() * 0.001 + enemy.x) * aiIntelligence * 0.5;
                        }
                        break;
                        
                    case 'aimed_shooter':
                        // Move toward player horizontally while going down
                        enemy.y += enemy.speed * 0.7;
                        const targetX = player.x + player.width / 2;
                        const currentX = enemy.x + enemy.width / 2;
                        
                        // Enhanced aiming with prediction
                        if (aiIntelligence > 0.5) {
                            // Predict player movement
                            const playerVelocity = player.speed;
                            const predictionTime = 0.5;
                            const predictedX = targetX + (playerVelocity * predictionTime * aiIntelligence);
                            
                            if (currentX < predictedX) {
                                enemy.x += enemy.speed * (0.5 + aiIntelligence * 0.3);
                            } else if (currentX > predictedX) {
                                enemy.x -= enemy.speed * (0.5 + aiIntelligence * 0.3);
                            }
                        } else {
                            if (currentX < targetX) {
                                enemy.x += enemy.speed * 0.5;
                            } else if (currentX > targetX) {
                                enemy.x -= enemy.speed * 0.5;
                            }
                        }
                        break;
                        
                    case 'patrol_shooter':
                        // Warship patrols horizontally while moving down slowly
                        enemy.y += enemy.speed * 0.3;
                        enemy.x += Math.sin(Date.now() * 0.002) * enemy.speed * 0.8;
                        
                        // Keep warship on screen
                        if (enemy.x < 50) enemy.x = 50;
                        if (enemy.x > canvas.width - enemy.width - 50) enemy.x = canvas.width - enemy.width - 50;
                        break;
                        
                    case 'kamikaze':
                        // Move directly toward player with enhanced pathfinding
                        const dx = (player.x + player.width / 2) - (enemy.x + enemy.width / 2);
                        const dy = (player.y + player.height / 2) - (enemy.y + enemy.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            // Add evasion behavior for higher waves
                            if (aiIntelligence > 0.4) {
                                // Evade bullets by moving perpendicular to player direction
                                const evadeX = -dy / distance * aiIntelligence * 0.3;
                                const evadeY = dx / distance * aiIntelligence * 0.3;
                                
                                enemy.x += (dx / distance) * enemy.speed + evadeX;
                                enemy.y += (dy / distance) * enemy.speed + evadeY;
                            } else {
                                enemy.x += (dx / distance) * enemy.speed;
                                enemy.y += (dy / distance) * enemy.speed;
                            }
                        }
                        break;
                }
                
                // Enemy shooting
                if (enemy.canShoot && Date.now() - enemy.lastFireTime > enemy.fireRate) {
                    if (enemy.weapon === 'seeking_missile') {
                        // Warship fires seeking missiles
                        createSeekingMissile(
                            enemy.x + enemy.width / 2,
                            enemy.y + enemy.height,
                            player.x + player.width / 2,
                            player.y + player.height / 2
                        );
                        playMissileSound();
                        enemy.lastFireTime = Date.now();
                    } else {
                        fireEnemyWeapon(enemy);
                        enemy.lastFireTime = Date.now();
                    }
                }
                
                // Check bullet collisions
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    if (checkCollision(bullet, enemy)) {
                        enemy.health -= bullet.damage;
                        if (!bullet.piercing) {
                            bullets.splice(j, 1);
                        }
                        
                        if (enemy.health <= 0) {
                            // Update combo system
                            updateCombo();
                            
                            // Calculate score with combo multiplier
                            const baseScore = enemy.points || 10;
                            const comboScore = baseScore * comboMultiplier;
                            score += comboScore;
                            
                            // Calculate coin reward with combo bonus
                            let coinReward = 5;
                            if (activePowerups.coinBoost && Date.now() < activePowerups.coinBoost) {
                                coinReward *= powerupsAvailable.coinBoost.multiplier;
                            }
                            
                            // Add combo bonus to coins (extra coins for high combos)
                            const comboCoinBonus = Math.floor(comboCount / 5) * 2; // +2 coins per 5 kills in combo
                            coinReward += comboCoinBonus;
                            
                            coins += coinReward;
                            coinsEarnedThisWave += coinReward;
                            enemiesKilled++;
                            enemiesKilledThisWave++;
                            
                            // Calculate loyalty with combo bonus
                            const baseLoyalty = enemy.loyaltyEarning || 0.000001;
                            const comboLoyaltyBonus = (comboMultiplier - 1) * baseLoyalty * 0.5; // 50% bonus loyalty per multiplier level
                            const totalLoyalty = baseLoyalty + comboLoyaltyBonus;
                            
                            loyaltyEarnings += totalLoyalty;
                            loyaltyEarnedThisWave += totalLoyalty;
                            loyalty += totalLoyalty;
                            wallet += totalLoyalty;
                            
                            // Visual effects
                            createExplosion(enemy.x, enemy.y);
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 8, enemy.color, 'explosion');
                            addScreenShake(3, 5);
                            playExplosionSound();
                            
                            // Combo particles for high combos
                            if (comboCount >= 5) {
                                createComboParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                playComboSound();
                            }
                            
                            // Show combo bonus messages
                            if (comboCoinBonus > 0) {
                                showRewardMessage(`üí∞ +${comboCoinBonus} COMBO BONUS!`);
                                playCoinSound();
                            }
                            if (comboLoyaltyBonus > 0) {
                                showRewardMessage(`üíé +${comboLoyaltyBonus.toFixed(6)} LOYALTY BONUS!`);
                            }
                            
                            enemies.splice(i, 1);
                            
                            // Update player stats
                            playerStats.totalEnemiesDestroyed++;
                            updatePlayerStats();
                            break;
                        }
                    }
                }
                
                // Check player collision using center mass for more realistic damage
                if (checkCenterMassCollision(enemy, player)) {
                    if (activePowerups.shield.charges > 0) {
                        activePowerups.shield.charges--;
                    } else {
                        health -= enemy.damage; // Use enemy's actual damage instead of fixed 20
                    }
                    enemies.splice(i, 1);
                    enemiesKilled++;
                    createExplosion(enemy.x, enemy.y);
                }
                
                // Remove enemies off screen
                if (enemy.y > canvas.height || enemy.x < -enemy.width || enemy.x > canvas.width) {
                    enemies.splice(i, 1);
                }
            }
            
            // Update powerups with optimized collision and magnet effect
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                powerup.y += 2;
                powerup.rotation += 0.1;
                powerup.pulse += 0.2;
                powerup.glow = Math.sin(powerup.pulse) * 0.5 + 0.5;
                
                // Magnet effect - pull powerups directly to ship center and absorb immediately
                if (activePowerups.magnet.active && activePowerups.magnet.endTime > Date.now()) {
                    // Calculate distance to ship center (pixel 1,1 relative to ship)
                    const shipCenterX = player.x + 1;
                    const shipCenterY = player.y + 1;
                    const dx = shipCenterX - (powerup.x + powerup.width / 2);
                    const dy = shipCenterY - (powerup.y + powerup.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < activePowerups.magnet.pullRadius) {
                        // Move powerup directly toward ship center
                        const pullSpeed = 0.7 + (activePowerups.magnet.level * 0.1);
                        powerup.x += dx * pullSpeed;
                        powerup.y += dy * pullSpeed;
                        
                        // Check if powerup has reached ship center
                        const newDx = shipCenterX - (powerup.x + powerup.width / 2);
                        const newDy = shipCenterY - (powerup.y + powerup.height / 2);
                        const newDistance = Math.sqrt(newDx * newDx + newDy * newDy);
                        
                        // Absorb immediately when reaching center
                        if (newDistance < 1) {
                            activatePowerup(powerup.type);
                            powerups.splice(i, 1);
                            
                            // Update player stats
                            playerStats.totalPowerupsCollected++;
                            updatePlayerStats();
                            continue;
                        }
                    }
                }
                
                // Manual collision check - only if magnet is not active
                if (!activePowerups.magnet.active || activePowerups.magnet.endTime <= Date.now()) {
                    // Quick collision check - only check if powerup is near player
                    if (powerup.y + powerup.height > player.y - 20 && 
                        powerup.y < player.y + player.height + 20 &&
                        powerup.x + powerup.width > player.x - 20 && 
                        powerup.x < player.x + player.width + 20) {
                    
                        if (checkCollision(powerup, player)) {
                            activatePowerup(powerup.type);
                            
                            // Powerup collection effects
                            createPowerupParticles(powerup.x + powerup.width/2, powerup.y + powerup.height/2, powerup.color);
                            addScreenShake(1, 3);
                            playPowerupSound();
                            
                            powerups.splice(i, 1);
                            
                            // Update player stats
                            playerStats.totalPowerupsCollected++;
                            updatePlayerStats();
                            continue;
                        }
                    }
                }
                
                if (powerup.y > canvas.height) {
                    powerups.splice(i, 1);
                }
            }
            
            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].life--;
                if (explosions[i].life <= 0) {
                    explosions.splice(i, 1);
                }
            }
            
            // Update power effects
            for (let i = powerEffects.length - 1; i >= 0; i--) {
                powerEffects[i].life--;
                powerEffects[i].angle += 0.1;
                if (powerEffects[i].life <= 0) {
                    powerEffects.splice(i, 1);
                }
            }
            
            // Update powerup messages
            for (let i = powerupMessages.length - 1; i >= 0; i--) {
                powerupMessages[i].life--;
                powerupMessages[i].y -= 0.5; // Float upward
                if (powerupMessages[i].life <= 0) {
                    powerupMessages.splice(i, 1);
                }
            }
            
            // Update seeking missiles
            updateSeekingMissiles();
            
            // Update missile explosions
            for (let i = missileExplosions.length - 1; i >= 0; i--) {
                missileExplosions[i].life--;
                if (missileExplosions[i].life <= 0) {
                    missileExplosions.splice(i, 1);
                }
            }
            
            // Update drone ally
            if (droneAlly && activePowerups.droneAlly && Date.now() < activePowerups.droneAlly) {
                // Move drone to follow player with smooth movement
                const targetX = player.x + player.width + 20;
                const targetY = player.y;
                
                droneAlly.x += (targetX - droneAlly.x) * 0.1;
                droneAlly.y += (targetY - droneAlly.y) * 0.1;
                
                // Drone fires at enemies with improved fire rate based on stacking
                if (Date.now() - droneAlly.lastFireTime > droneAlly.fireRate) {
                    // Find closest enemy for drone to target
                    let closestEnemy = null;
                    let closestDistance = Infinity;
                    
                    for (let enemy of enemies) {
                        const distance = Math.sqrt(
                            Math.pow(enemy.x - droneAlly.x, 2) + 
                            Math.pow(enemy.y - droneAlly.y, 2)
                        );
                        if (distance < closestDistance && enemy.y < droneAlly.y) {
                            closestDistance = distance;
                            closestEnemy = enemy;
                        }
                    }
                    
                    if (closestEnemy) {
                        bullets.push({
                            x: droneAlly.x + droneAlly.width / 2 - 2,
                            y: droneAlly.y,
                            width: 4,
                            height: 8,
                            speed: 6,
                            damage: 15 + (droneAlly.level || 1) * 5, // Increased damage with stacking
                            color: '#00ff00',
                            isDroneBullet: true
                        });
                        droneAlly.lastFireTime = Date.now();
                    }
                }
            } else if (droneAlly && (!activePowerups.droneAlly || Date.now() >= activePowerups.droneAlly)) {
                // Drone powerup expired, remove drone
                droneAlly = null;
            }
            
            // Check boss collision with player bullets
        if (bossActive && currentBoss) {
            for (let j = bullets.length - 1; j >= 0; j--) {
                const bullet = bullets[j];
                if (!bullet.isBossBullet && checkCollision(bullet, currentBoss)) {
                    // Handle shield damage first
                    if (currentBoss.shields && currentBoss.shields.length > 0 && currentBoss.currentShieldIndex < currentBoss.shields.length) {
                        const currentShield = currentBoss.shields[currentBoss.currentShieldIndex];
                        currentShield.health -= bullet.damage;
                        currentBoss.remainingShieldHealth -= bullet.damage;
                        
                        // Check if current shield is destroyed
                        if (currentShield.health <= 0) {
                            currentBoss.currentShieldIndex++;
                            
                            // If all shields are destroyed, trigger phase transition
                            if (currentBoss.currentShieldIndex >= currentBoss.shields.length) {
                                currentBoss.phase = Math.min(currentBoss.maxPhase, currentBoss.phase + 1);
                                currentBoss.fireRate = Math.max(500, currentBoss.fireRate - 200);
                                currentBoss.minionSpawnRate = Math.max(2000, currentBoss.minionSpawnRate - 1000);
                                showBossPhaseTransition();
                                showRewardMessage(`üõ°Ô∏è SHIELDS DESTROYED! PHASE ${currentBoss.phase}!`);
                            } else {
                                showRewardMessage(`üõ°Ô∏è Shield ${currentBoss.currentShieldIndex}/${currentBoss.shields.length} destroyed!`);
                            }
                        }
                    } else {
                        // No shields left, damage the boss directly
                        currentBoss.health -= bullet.damage;
                    }
                    
                    if (!bullet.piercing) {
                        bullets.splice(j, 1);
                    }
                    createExplosion(bullet.x, bullet.y);
                }
            }
        }
            
            // Update stars
            for (let star of stars) {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            }
            
                    // Check for boss spawn
        if (currentWave % bossSpawnWave === 0 && !bossActive && !bossWarningShown && enemies.length === 0) {
            showBossWarning();
        } else if (currentWave % bossSpawnWave !== 0 && bossWaveCount === 0) {
            // Initialize boss variables for non-boss waves
            maxBossWaves = 0;
            bossDefeatedCount = 0;
        }
        
        // Update boss
        if (bossActive && currentBoss) {
            updateBoss();
        }
        
        // Check level completion (only if no boss is active AND all bosses in wave are defeated)
        if (enemiesKilledThisWave >= enemiesRequiredForLevel && !levelCompleteMenuShouldBeShown && gameRunning && !bossActive && (maxBossWaves === 0 || bossDefeatedCount >= maxBossWaves)) {
            console.log(`Level ${currentWave} Complete! Killed: ${enemiesKilledThisWave}/${enemiesRequiredForLevel}, Bosses: ${bossDefeatedCount}/${maxBossWaves}`);
            playLevelUpSound();
            showLevelCompleteMenu();
        }
         
            // Check game over
        if (health <= 0) {
                gameOver();
        }
            
            updateHUD();
        }
        
                 function draw() {
             // Apply screen shake
             ctx.save();
             ctx.translate(screenShake.x, screenShake.y);
             
             // Draw background
            if (sprites.backgrounds.space && sprites.backgrounds.space.complete) {
                 // Create repeating background pattern
                 const pattern = ctx.createPattern(sprites.backgrounds.space, 'repeat');
                 ctx.fillStyle = pattern;
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
             } else {
                 // Fallback to black background
                 ctx.fillStyle = '#000';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
             }
             
                      // Draw enhanced stars with twinkling effect
         for (let star of stars) {
             const twinkle = Math.sin(Date.now() * 0.001 + star.x * 0.01) * 0.5 + 0.5;
             ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
             ctx.shadowColor = '#fff';
             ctx.shadowBlur = 2;
             ctx.fillRect(star.x, star.y, 1, 1);
             ctx.shadowBlur = 0;
         }
         
         // Draw particles
         for (let particle of particles) {
             const alpha = particle.life / particle.maxLife;
             ctx.globalAlpha = alpha;
             ctx.fillStyle = particle.color;
             ctx.shadowColor = particle.color;
             ctx.shadowBlur = 5;
             
             if (particle.type === 'combo') {
                 // Combo particles are stars
                 ctx.fillText('‚òÖ', particle.x, particle.y);
             } else {
                 // Other particles are circles
                 ctx.beginPath();
                 ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                 ctx.fill();
             }
             
             ctx.shadowBlur = 0;
         }
         ctx.globalAlpha = 1;
             
                      // Draw player ship with enhanced visuals
         const ship = ships[player.currentShip];
         const playerSprite = sprites.playerShips[ship.level] || sprites.playerShips[1];
         
         // Draw player ship glow effect
         ctx.shadowColor = ship.color;
         ctx.shadowBlur = 15;
            
            try {
                if (playerSprite && playerSprite.complete && playerSprite.naturalWidth > 0) {
                    // Draw actual sprite
                    ctx.drawImage(playerSprite, player.x, player.y, player.width, player.height);
                } else {
                    // Fallback to colored rectangle
                    ctx.fillStyle = ship.color;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
            } catch (e) {
                // Fallback to colored rectangle
                ctx.fillStyle = ship.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
            
            // Draw enhanced exhaust effect
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(player.x + player.width / 2 - 5, player.y + player.height, 10, 8);
            ctx.shadowBlur = 15;
         
         ctx.shadowBlur = 0;
         
         // Draw enhanced ship details
         ctx.fillStyle = '#fff';
         ctx.font = 'bold 12px Arial';
         ctx.textAlign = 'center';
         ctx.fillText(ship.name, player.x + player.width / 2, player.y - 8);
         ctx.textAlign = 'left';
         
         // Draw ship level indicator
         ctx.fillStyle = ship.color;
         ctx.font = '10px Arial';
         ctx.textAlign = 'center';
         ctx.fillText(`Level ${ship.level}`, player.x + player.width / 2, player.y + player.height + 12);
         ctx.textAlign = 'left';
         
         // Draw shield indicator dots
         if (activePowerups.shield.charges > 0) {
             const dotSize = 6;
             const dotSpacing = 8;
             const totalWidth = (activePowerups.shield.maxCharges * dotSpacing) - dotSpacing;
             const startX = player.x + player.width / 2 - totalWidth / 2;
             const dotY = player.y + player.height + 25;
             
             for (let i = 0; i < activePowerups.shield.maxCharges; i++) {
                 const dotX = startX + (i * dotSpacing);
                 
                 if (i < activePowerups.shield.charges) {
                     // Active shield charge - glowing blue
                     ctx.shadowColor = '#00ffff';
                     ctx.shadowBlur = 8;
                     ctx.fillStyle = '#00ffff';
                 } else {
                     // Empty charge - dim gray
                     ctx.shadowBlur = 0;
                     ctx.fillStyle = '#444444';
                 }
                 
                 ctx.beginPath();
                 ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
                 ctx.fill();
             }
            }
            
            // Draw enhanced bullets with weapon effects
         for (let bullet of bullets) {
                ctx.shadowColor = bullet.color || '#ffff00';
                ctx.shadowBlur = 5;
                ctx.fillStyle = bullet.color || '#ffff00';
                 ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                 ctx.shadowBlur = 0;
         }
             
            // Draw boss
            if (bossActive && currentBoss) {
                const bossSprite = sprites.bossShips[currentBoss.type];
                
                ctx.save();
                
                // Draw boss sprite
                try {
                    if (bossSprite && bossSprite.complete && bossSprite.naturalWidth > 0) {
                        ctx.drawImage(bossSprite, currentBoss.x, currentBoss.y, currentBoss.width, currentBoss.height);
                    } else {
                        // Fallback boss drawing
                        ctx.fillStyle = currentBoss.color;
                        ctx.fillRect(currentBoss.x, currentBoss.y, currentBoss.width, currentBoss.height);
                    }
                } catch (e) {
                    ctx.fillStyle = currentBoss.color;
                    ctx.fillRect(currentBoss.x, currentBoss.y, currentBoss.width, currentBoss.height);
                }
                
                // Draw shield bars (if any)
                if (currentBoss.shields && currentBoss.shields.length > 0) {
                    const shieldBarHeight = 8;
                    const shieldBarSpacing = 2;
                    let shieldBarY = currentBoss.y - 35 - (currentBoss.shields.length * (shieldBarHeight + shieldBarSpacing));
                    
                    for (let i = 0; i < currentBoss.shields.length; i++) {
                        const shield = currentBoss.shields[i];
                        const shieldPercent = shield.health / shield.maxHealth;
                        
                        // Shield background
                        ctx.fillStyle = '#333';
                        ctx.fillRect(currentBoss.x, shieldBarY, currentBoss.width, shieldBarHeight);
                        
                        // Shield health
                        ctx.fillStyle = shield.color;
                        ctx.fillRect(currentBoss.x, shieldBarY, currentBoss.width * shieldPercent, shieldBarHeight);
                        
                        // Shield border
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(currentBoss.x, shieldBarY, currentBoss.width, shieldBarHeight);
                        
                        // Shield label
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(`Shield ${i + 1}: ${Math.ceil(shield.health)}/${shield.maxHealth}`, currentBoss.x + 5, shieldBarY + 6);
                        
                        shieldBarY += shieldBarHeight + shieldBarSpacing;
                    }
                }
                
                // Draw boss health bar
                const healthBarWidth = currentBoss.width;
                const healthBarHeight = 10;
                const healthPercent = currentBoss.health / currentBoss.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(currentBoss.x, currentBoss.y - 20, healthBarWidth, healthBarHeight);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(currentBoss.x, currentBoss.y - 20, healthBarWidth * healthPercent, healthBarHeight);
                
                // Draw boss name
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(currentBoss.name, currentBoss.x + currentBoss.width / 2, currentBoss.y - 25);
                
                // Draw phase indicator
                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(`PHASE ${currentBoss.phase}/${currentBoss.maxPhase}`, currentBoss.x + currentBoss.width / 2, currentBoss.y - 5);
                
                ctx.restore();
            }
            
            // Draw enemies with sprites
         for (let enemy of enemies) {
                const enemySprite = sprites.enemyShips[enemy.type];
                
                // Special effects for warship
                if (enemy.type === 'warship') {
                    // Draw warship glow effect
                    ctx.shadowColor = '#8B0000';
                    ctx.shadowBlur = 15;
                    
                    // Draw warning indicator
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ö†Ô∏è WARSHIP ‚ö†Ô∏è', enemy.x + enemy.width / 2, enemy.y - 15);
                    ctx.textAlign = 'left';
                }
                
                try {
                    if (enemySprite && enemySprite.complete && enemySprite.naturalWidth > 0) {
                        // Draw actual sprite
                        ctx.drawImage(enemySprite, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else {
                        // Fallback to colored rectangle
                        ctx.fillStyle = enemy.color;
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                } catch (e) {
                    // Fallback to colored rectangle
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                }
             
                // Draw enhanced health bar
                const healthPercent = enemy.health / enemy.maxHealth;
             ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * healthPercent, 5);
            }
            
            // Draw enhanced powerups with sprites and cool effects
         for (let powerup of powerups) {
                const powerupSprite = sprites.powerups[powerup.type];
                
                ctx.save();
                ctx.translate(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2);
                ctx.rotate(powerup.rotation);
                
                // Draw outer glow ring
                const glowSize = 60 + (powerup.glow * 20);
                ctx.shadowColor = powerup.color;
                ctx.shadowBlur = 15 + (powerup.glow * 10);
                ctx.strokeStyle = powerup.color;
                  ctx.lineWidth = 3;
                  ctx.beginPath();
                ctx.arc(0, 0, glowSize / 2, 0, Math.PI * 2);
                  ctx.stroke();
                
                // Draw inner pulsing circle
                const innerSize = 40 + (powerup.glow * 10);
                ctx.fillStyle = powerup.color;
                ctx.globalAlpha = 0.3 + (powerup.glow * 0.4);
                ctx.beginPath();
                ctx.arc(0, 0, innerSize / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw sprite or fallback
                try {
                    if (powerupSprite && powerupSprite.complete && powerupSprite.naturalWidth > 0) {
                        ctx.globalAlpha = 1;
                        ctx.shadowColor = powerup.color;
                        ctx.shadowBlur = 10;
                        ctx.drawImage(powerupSprite, -powerup.width / 2, -powerup.height / 2, powerup.width, powerup.height);
                        console.log(`‚úÖ Drawing sprite for ${powerup.type}`);
                  } else {
                        // Fallback to colored rectangle with debug info
                        console.log(`‚ö†Ô∏è Powerup ${powerup.type} using fallback - sprite not loaded`);
                        console.log(`Sprite object:`, powerupSprite);
                        console.log(`Sprite complete:`, powerupSprite ? powerupSprite.complete : 'no sprite');
                        console.log(`Sprite naturalWidth:`, powerupSprite ? powerupSprite.naturalWidth : 'no sprite');
                        ctx.globalAlpha = 1;
                        ctx.shadowColor = powerup.color;
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = powerup.color;
                        ctx.fillRect(-powerup.width / 2, -powerup.height / 2, powerup.width, powerup.height);
                    }
                } catch (e) {
                    // Error fallback to colored rectangle
                    console.log(`‚ùå Powerup ${powerup.type} sprite error:`, e);
                    ctx.globalAlpha = 1;
                    ctx.shadowColor = powerup.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = powerup.color;
                    ctx.fillRect(-powerup.width / 2, -powerup.height / 2, powerup.width, powerup.height);
                }
                
                ctx.restore();
                
                // Draw floating powerup label with glow
                ctx.save();
                ctx.shadowColor = powerup.color;
                ctx.shadowBlur = 5;
              ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(powerup.type.toUpperCase(), powerup.x + powerup.width / 2, powerup.y - 10);
                ctx.restore();
            }
            
            // Draw power effects
            for (let effect of powerEffects) {
             const alpha = effect.life / effect.maxLife;
                const size = 30 * alpha;
             
             ctx.save();
             ctx.globalAlpha = alpha;
             
                switch(effect.type) {
                    case 'shieldActivate':
                        ctx.fillStyle = '#0080ff';
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'speedActivate':
                    case 'speedStack':
                     ctx.fillStyle = '#ffff00';
                     ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'damageActivate':
                    case 'damageStack':
                        ctx.fillStyle = '#ff4444';
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'rapidFireActivate':
                    case 'rapidFireStack':
                        ctx.fillStyle = '#ff8800';
                         ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                         ctx.fill();
                     break;
                    case 'multipleShotsActivate':
                    case 'multipleShotsStack':
                     ctx.fillStyle = '#8000ff';
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'magnetActivate':
                    case 'magnetStack':
                        ctx.fillStyle = '#ff1493';
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'droneActivate':
                    case 'droneStack':
                        ctx.fillStyle = '#00ff00';
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'repairActivate':
                        ctx.fillStyle = '#00ffff';
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'piercingActivate':
                    case 'piercingStack':
                        ctx.fillStyle = '#ff00ff';
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                     ctx.fill();
                     break;
                    case 'coinBoostActivate':
                    case 'coinBoostStack':
                        ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    case 'premiumActivate':
                        ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                    ctx.fill();
                        break;
                }
                
                ctx.restore();
            }
            
            // Draw powerup messages
            for (let message of powerupMessages) {
                const alpha = message.life / message.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = message.color;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                ctx.fillText(message.text, message.x, message.y);
                ctx.restore();
            }
            
            // Draw drone ally with enhanced debugging
            if (droneAlly && activePowerups.droneAlly && Date.now() < activePowerups.droneAlly) {
                const droneSprite = sprites.powerups.droneAlly;
                
                // Debug logging (only once per second)
                if (Math.floor(Date.now() / 1000) % 5 === 0) {
                    console.log('ü§ñ Drone Status:', {
                        sprite: droneSprite ? 'loaded' : 'missing',
                        complete: droneSprite ? droneSprite.complete : false,
                        naturalWidth: droneSprite ? droneSprite.naturalWidth : 0,
                        src: droneSprite ? droneSprite.src : 'none',
                        position: { x: droneAlly.x, y: droneAlly.y },
                        size: { w: droneAlly.width, h: droneAlly.height }
                    });
                }
                
                ctx.save();
                
                try {
                    if (droneSprite && droneSprite.complete && droneSprite.naturalWidth > 0) {
                        // Draw drone sprite with enhanced glow effect
                        ctx.shadowColor = '#00ff00';
                        ctx.shadowBlur = 15;
                        ctx.drawImage(droneSprite, droneAlly.x, droneAlly.y, droneAlly.width, droneAlly.height);
                        console.log('‚úÖ Drawing drone sprite at:', droneAlly.x, droneAlly.y);
                    } else {
                        // Enhanced fallback drone drawing
                        ctx.shadowColor = '#00ff00';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(droneAlly.x, droneAlly.y, droneAlly.width, droneAlly.height);
                        
                        // Draw drone details
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(droneAlly.x + 2, droneAlly.y + 2, droneAlly.width - 4, droneAlly.height - 4);
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(droneAlly.x + droneAlly.width / 2 - 1, droneAlly.y - 3, 2, 6);
                        
                        // Add warning text for debugging
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('FALLBACK', droneAlly.x + droneAlly.width / 2, droneAlly.y + droneAlly.height + 15);
                    }
                } catch (e) {
                    console.error('‚ùå Error drawing drone:', e);
                    // Fallback drone drawing
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(droneAlly.x, droneAlly.y, droneAlly.width, droneAlly.height);
                }
                
                ctx.restore();
                
                // Draw drone label
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 2;
                ctx.fillText('DRONE', droneAlly.x + droneAlly.width / 2, droneAlly.y - 8);
                ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
                
                // Draw drone duration bar
                const timeLeft = Math.max(0, activePowerups.droneAlly - Date.now());
                const timePercent = timeLeft / 20000;
                ctx.fillStyle = '#333';
                ctx.fillRect(droneAlly.x, droneAlly.y + droneAlly.height + 2, droneAlly.width, 3);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(droneAlly.x, droneAlly.y + droneAlly.height + 2, droneAlly.width * timePercent, 3);
            }
            
            // Draw enhanced explosions
            for (let explosion of explosions) {
                const alpha = explosion.life / explosion.maxLife;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                    ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Draw seeking missiles
            for (let missile of seekingMissiles) {
                // Draw missile trail
                for (let i = 0; i < missile.trail.length; i++) {
                    const trail = missile.trail[i];
                    const alpha = trail.life / 10;
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 5;
                    ctx.fillRect(trail.x - 3, trail.y - 3, 6, 6);
                }
                ctx.globalAlpha = 1;
                
                // Try to draw missile sprite first
                const missileSprite = sprites.effects.missile;
                try {
                    if (missileSprite && missileSprite.complete && missileSprite.naturalWidth > 0) {
                        // Draw missile sprite
                        ctx.save();
                        ctx.translate(missile.x, missile.y);
                        
                        // Calculate angle to face the direction of movement
                        const angle = Math.atan2(missile.vy, missile.vx);
                        ctx.rotate(angle);
                        
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 12;
                        ctx.drawImage(missileSprite, -missile.width/2, -missile.height/2, missile.width, missile.height);
                        ctx.restore();
                    } else {
                        // Fallback to enhanced drawing
                        ctx.fillStyle = missile.color;
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 12;
                        ctx.fillRect(missile.x - missile.width/2, missile.y - missile.height/2, missile.width, missile.height);
                        
                        // Draw missile tip
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(missile.x - missile.width/2, missile.y - missile.height/2, missile.width, 6);
                        
                        // Draw missile fins
                        ctx.fillStyle = '#ffaa00';
                        ctx.fillRect(missile.x - missile.width/2 - 2, missile.y + missile.height/2 - 4, 4, 8);
                        ctx.fillRect(missile.x + missile.width/2 - 2, missile.y + missile.height/2 - 4, 4, 8);
                    }
                } catch (e) {
                    // Fallback to enhanced drawing
                    ctx.fillStyle = missile.color;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 12;
                    ctx.fillRect(missile.x - missile.width/2, missile.y - missile.height/2, missile.width, missile.height);
                    
                    // Draw missile tip
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(missile.x - missile.width/2, missile.y - missile.height/2, missile.width, 6);
                    
                    // Draw missile fins
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(missile.x - missile.width/2 - 2, missile.y + missile.height/2 - 4, 4, 8);
                    ctx.fillRect(missile.x + missile.width/2 - 2, missile.y + missile.height/2 - 4, 4, 8);
                }
                
                // Draw warning glow
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(missile.x - missile.width/2 - 2, missile.y - missile.height/2 - 2, missile.width + 4, missile.height + 4);
                
                ctx.shadowBlur = 0;
            }
            
            // Draw missile explosions
            for (let explosion of missileExplosions) {
                const alpha = explosion.life / explosion.maxLife;
                ctx.strokeStyle = `rgba(255, 102, 0, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius * alpha, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw explosion fill
                ctx.fillStyle = `rgba(255, 102, 0, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw magnet radius ring when magnet is active
            if (activePowerups.magnet.active && activePowerups.magnet.endTime > Date.now()) {
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                const radius = activePowerups.magnet.pullRadius;
                const level = activePowerups.magnet.level;
                
                // Draw pulsing magnet ring
                ctx.save();
                ctx.globalAlpha = 0.3 + (Math.sin(Date.now() * 0.005) * 0.1);
                ctx.strokeStyle = '#ff1493';
                ctx.lineWidth = 2 + (level * 0.5);
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw inner glow
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = '#ff1493';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw magnet level indicator
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ff1493';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`MAGNET Lv.${level}`, centerX, centerY - radius - 10);
                ctx.textAlign = 'left';
                
                ctx.restore();
            }
            
            // Draw visual feedback overlays
            ctx.restore(); // Restore from screen shake
            
            // Damage flash overlay
            if (damageFlash > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash / 15 * 0.3})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Low health pulse overlay
            if (lowHealthPulse > 0) {
                const pulseIntensity = Math.sin(lowHealthPulse) * 0.2 + 0.1;
                ctx.fillStyle = `rgba(255, 0, 0, ${pulseIntensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Combo display
            if (comboCount > 0) {
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 4;
                ctx.fillText(`COMBO x${comboMultiplier}`, canvas.width / 2, 100);
                ctx.fillText(`${comboCount} Kills!`, canvas.width / 2, 130);
                ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
            }
        }
        
        // ===== HELPER FUNCTIONS =====
        function spawnEnemies() {
            // Max 30 enemies on screen, spawn more when below 30
            if (enemies.length < 30) {
                const spawnChance = 0.03 + (currentWave * 0.005); // Slightly higher spawn rate as waves progress
                
                if (Math.random() < spawnChance) {
                    // Check for warship spawn (mini-boss)
                    let enemyTypeKeys = Object.keys(enemyTypes);
                    let type;
                    
                    // Warship has special spawn logic
                    if (currentWave >= 3 && Math.random() < 0.02) { // 2% chance for warship after wave 3
                        type = 'warship';
                        playWarshipSound(); // Play warning sound when warship spawns
                        console.log('üö¢ WARSHIP SPAWNED!'); // Debug message
                    } else {
                        // Filter out warship from regular spawns
                        enemyTypeKeys = enemyTypeKeys.filter(key => key !== 'warship');
                        type = enemyTypeKeys[Math.floor(Math.random() * enemyTypeKeys.length)];
                    }
                    
                    const enemyData = enemyTypes[type];
                    
                    // Scale enemy stats with wave level
                    const waveMultiplier = 1 + (currentWave - 1) * 0.1; // 10% increase per wave
                    
                    const enemy = {
                        x: Math.random() * (canvas.width - (enemyData.isMiniBoss ? 80 : 40)),
                        y: enemyData.isMiniBoss ? -80 : -40, // Start higher for bigger warship
                        width: enemyData.isMiniBoss ? 80 : 40, // 2x bigger for warship
                        height: enemyData.isMiniBoss ? 80 : 40, // 2x bigger for warship
                        health: Math.floor(enemyData.health * waveMultiplier),
                        maxHealth: Math.floor(enemyData.health * waveMultiplier),
                        speed: enemyData.speed * (1 + (currentWave - 1) * 0.05), // 5% speed increase per wave
                        damage: Math.floor(enemyData.damage * waveMultiplier),
                        color: enemyData.color,
                        weapon: enemyData.weapon,
                        ai: enemyData.ai,
                        fireRate: Math.max(500, enemyData.fireRate - (currentWave - 1) * 100), // Faster firing as waves progress
                        lastFireTime: Date.now(),
                        canShoot: currentWave >= 3, // Enable shooting from wave 3
                        type: type,
                        wave: currentWave, // Track which wave this enemy spawned in
                        loyaltyEarning: enemyData.loyaltyEarning, // Copy loyalty earning from template
                        points: enemyData.points // Copy points from template
                    };
                    
                    enemies.push(enemy);
                }
            }
            
            // Spawn powerups occasionally
            if (Math.random() < 0.005) {
                const powerupTypes = Object.keys(powerupsAvailable);
                const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                
                const powerup = {
                    x: Math.random() * (canvas.width - 50),
                    y: -50,
                    width: 50,
                    height: 50,
                    type: type,
                    color: powerupsAvailable[type].color,
                    rotation: 0,
                    pulse: 0,
                    glow: 0
                };
                
                powerups.push(powerup);
            }
        }
        
        function fireShipWeapon() {
            const ship = ships[player.currentShip];
            const bulletWidth = 4;
            const bulletHeight = 8;
            const bulletSpeed = 8;
            
            // Check if piercing laser is active
            const isPiercing = activePowerups.piercingLaser.active && activePowerups.piercingLaser.shotsRemaining > 0;
            
            // Determine number of guns based on ship level
            let gunCount = ship.level; // Level 1 = 1 gun, Level 2 = 2 guns, etc.
            
            // Multiple shots powerup doubles the gun count
            if (activePowerups.multipleShots && Date.now() < activePowerups.multipleShots) {
                gunCount *= 2;
            }
            
            // Fire bullets for each gun
            for (let i = 0; i < gunCount; i++) {
                let bulletX;
                
                if (gunCount === 1) {
                    // Single gun - center
                    bulletX = player.x + player.width / 2 - bulletWidth / 2;
                } else {
                    // Multiple guns - spread across ship width
                    const spacing = (player.width - bulletWidth) / (gunCount - 1);
                    bulletX = player.x + (i * spacing);
                }
                
                bullets.push({
                    x: bulletX,
                    y: player.y,
                    width: bulletWidth,
                    height: bulletHeight,
                    speed: bulletSpeed,
                    damage: ship.damage * (isPiercing ? 2 : 1),
                    color: isPiercing ? '#ff00ff' : ship.color,
                    piercing: isPiercing
                });
            }
            
            // Decrease piercing laser shots if active
            if (isPiercing) {
                activePowerups.piercingLaser.shotsRemaining--;
                if (activePowerups.piercingLaser.shotsRemaining <= 0) {
                    activePowerups.piercingLaser.active = false;
                }
            }
         }
        
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // Center mass collision detection for more realistic damage
        function checkCenterMassCollision(rect1, rect2) {
            // Calculate center points
            const center1X = rect1.x + rect1.width / 2;
            const center1Y = rect1.y + rect1.height / 2;
            const center2X = rect2.x + rect2.width / 2;
            const center2Y = rect2.y + rect2.height / 2;
            
            // Calculate distance between centers
            const distance = Math.sqrt(
                Math.pow(center1X - center2X, 2) + 
                Math.pow(center1Y - center2Y, 2)
            );
            
            // Define center mass collision radius (smaller than full collision)
            const collisionRadius = Math.min(rect1.width, rect1.height) * 0.3; // 30% of smaller dimension
            
            return distance < collisionRadius;
        }
        
        function createExplosion(x, y) {
            explosions.push({
                x: x,
                y: y,
                size: 20,
                life: 10,
                maxLife: 10
            });
        }
        
                         function activatePowerup(type) {
            console.log(`Powerup activated: ${type}`);
            
            if (type === 'shield') {
                if (activePowerups.shield.charges < activePowerups.shield.maxCharges) {
                    activePowerups.shield.charges++;
                    createPowerEffect('shieldActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            } else if (type === 'speed') {
                const currentTime = Date.now();
                if (activePowerups.speed && activePowerups.speed > currentTime) {
                    // Stack speed boost - extend duration
                    activePowerups.speed += 8000;
                } else {
                    activePowerups.speed = currentTime + 8000;
                createPowerEffect('speedActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
                player.speed = 6;
            } else if (type === 'damage') {
                const currentTime = Date.now();
                if (activePowerups.damage && activePowerups.damage > currentTime) {
                    // Stack damage boost - extend duration
                    activePowerups.damage += 12000;
                } else {
                    activePowerups.damage = currentTime + 12000;
                createPowerEffect('damageActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            } else if (type === 'rapidFire') {
                const currentTime = Date.now();
                if (activePowerups.rapidFire && activePowerups.rapidFire > currentTime) {
                    // Stack rapid fire - extend duration
                    activePowerups.rapidFire += 15000;
                } else {
                    activePowerups.rapidFire = currentTime + 15000;
                createPowerEffect('rapidFireActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            } else if (type === 'multipleShots') {
                const currentTime = Date.now();
                if (activePowerups.multipleShots && activePowerups.multipleShots > currentTime) {
                    // Stack multiple shots - extend duration
                    activePowerups.multipleShots += 12000;
                } else {
                    activePowerups.multipleShots = currentTime + 12000;
                createPowerEffect('multipleShotsActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            } else if (type === 'magnet') {
                const currentTime = Date.now();
                if (activePowerups.magnet.active && activePowerups.magnet.endTime > currentTime) {
                    // Stack magnet - extend duration and increase power significantly
                    activePowerups.magnet.endTime += 15000;
                    activePowerups.magnet.level++;
                    activePowerups.magnet.pullRadius += 30; // Bigger radius increase
                    activePowerups.magnet.pullStrength += 1.0; // Stronger pull increase
                    createPowerEffect('magnetStack', player.x + player.width / 2, player.y + player.height / 2);
                } else {
                    activePowerups.magnet.active = true;
                    activePowerups.magnet.endTime = currentTime + 15000;
                    activePowerups.magnet.level = 1;
                    activePowerups.magnet.pullRadius = 150; // Starting with bigger radius
                    activePowerups.magnet.pullStrength = 4; // Starting with stronger pull
                createPowerEffect('magnetActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            } else if (type === 'nanobotRepair') {
                health = Math.min(100, health + 20);
                createPowerEffect('repairActivate', player.x + player.width / 2, player.y + player.height / 2);
            } else if (type === 'droneAlly') {
                const currentTime = Date.now();
                if (activePowerups.droneAlly && activePowerups.droneAlly > currentTime) {
                    // Stack drone ally - extend duration and improve fire rate
                    activePowerups.droneAlly += 20000;
                    if (droneAlly) {
                        // Improve fire rate with stacking (faster firing)
                        droneAlly.fireRate = Math.max(200, 600 - (activePowerups.droneAlly / 20000) * 100);
                    }
                    createPowerEffect('droneStack', player.x + player.width / 2, player.y + player.height / 2);
                } else {
                    activePowerups.droneAlly = currentTime + 20000;
                    droneAlly = {
                        x: player.x + player.width + 20,
                        y: player.y,
                        width: 30,
                        height: 30,
                        speed: 2,
                        lastFireTime: 0,
                        fireRate: 600,
                        level: 1
                    };
                    createPowerEffect('droneActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            } else if (type === 'piercingLaser') {
                if (activePowerups.piercingLaser.active) {
                    // Stack piercing laser - add more shots
                    activePowerups.piercingLaser.shotsRemaining += 10;
                } else {
                activePowerups.piercingLaser.active = true;
                activePowerups.piercingLaser.shotsRemaining = 10;
                createPowerEffect('piercingActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            } else if (type === 'coinBoost') {
                const currentTime = Date.now();
                if (activePowerups.coinBoost && activePowerups.coinBoost > currentTime) {
                    // Stack coin boost - extend duration
                    activePowerups.coinBoost += 10000;
                    createPowerEffect('coinBoostStack', player.x + player.width / 2, player.y + player.height / 2);
                } else {
                    activePowerups.coinBoost = currentTime + 10000;
                    createPowerEffect('coinBoostActivate', player.x + player.width / 2, player.y + player.height / 2);
                }
            }
            
            // Show powerup activation message (only for new activations, not stacking)
            showPowerupMessage(type);
        }
        
        function createPowerEffect(type, x, y) {
            powerEffects.push({
                type: type,
                x: x,
                y: y,
                life: 60,
                maxLife: 60,
                angle: 0
            });
        }
        
        function showPowerupMessage(type) {
            const messages = {
                shield: { text: 'üõ°Ô∏è SHIELD CHARGE ADDED!', color: '#0080ff' },
                speed: { text: '‚ö° SPEED BOOST!', color: '#ffff00' },
                damage: { text: 'üí• DAMAGE BOOST!', color: '#ff4444' },
                rapidFire: { text: 'üî• RAPID FIRE!', color: '#ff8800' },
                multipleShots: { text: 'üéØ MULTIPLE SHOTS!', color: '#8000ff' },
                magnet: { text: 'üß≤ MAGNET POWER!', color: '#ff1493' },
                droneAlly: { text: 'ü§ñ DRONE ALLY DEPLOYED!', color: '#00ff00' },
                nanobotRepair: { text: 'üîß +20 HP RESTORED!', color: '#00ffff' },
                piercingLaser: { text: '‚ö° PIERCING LASER READY!', color: '#ff00ff' },
                coinBoost: { text: 'üí∞ COIN BOOST ACTIVE!', color: '#ffd700' },
                // Premium powerup messages
                megaShield: { text: 'üíé MEGA SHIELD ACTIVATED!', color: '#00ffff' },
                hyperSpeed: { text: '   HYPER SPEED BOOST!', color: '#ff00ff' },
                ultimateDamage: { text: 'üíé ULTIMATE DAMAGE!', color: '#ff4444' },
                infiniteRapidFire: { text: 'üíé INFINITE RAPID FIRE!', color: '#ff8800' },
                superMagnet: { text: 'üíé SUPER MAGNET POWER!', color: '#ff1493' }
            };
            
            const message = messages[type];
            if (message) {
                powerupMessages.push({
                    text: message.text,
                    color: message.color,
                    x: player.x + player.width / 2,
                    y: player.y - 50,
                    life: 120,
                    maxLife: 120
                });
            }
        }
        
        // ===== AD MONETIZATION SYSTEM =====
        function showAdModal(type, callback) {
            const adModal = document.createElement('div');
            adModal.id = 'adModal';
            adModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 2000;
                color: white;
                font-family: Arial, sans-serif;
            `;
            
            const adContent = document.createElement('div');
            adContent.style.cssText = `
                background: linear-gradient(45deg, #1a1a2e, #16213e);
                border: 2px solid #00ffff;
                border-radius: 15px;
                padding: 30px;
                text-align: center;
                max-width: 400px;
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            `;
            
            let adTitle, adDescription, adReward;
            
            switch(type) {
                case 'doubleEarnings':
                    adTitle = 'üí∞ Double Your Earnings!';
                    adDescription = 'Watch a short ad to double your coins and loyalty earnings from this wave!';
                    adReward = `Reward: ${coinsEarnedThisWave * 2} coins + $${(loyaltyEarnedThisWave * 2).toFixed(6)}`;
                    break;
                case 'revive':
                    adTitle = 'üõ°Ô∏è Revive Your Ship!';
                    adDescription = 'Watch an ad to revive your ship and continue the battle!';
                    adReward = 'Reward: Full health restoration';
                    break;
                case 'bonusCoins':
                    adTitle = 'üéÅ Bonus Coins!';
                    adDescription = 'Watch an ad to get bonus coins for your next purchase!';
                    adReward = 'Reward: 100 bonus coins';
                    break;
                case 'speedUpBuild':
                    adTitle = '‚ö° Speed Up Construction!';
                    adDescription = 'Watch an ad to instantly complete ship construction!';
                    adReward = 'Reward: Instant ship completion';
                    break;
                case 'revCoins':
                    adTitle = 'üíé Earn RevCoins!';
                    adDescription = 'Watch an ad to earn RevCoins for premium weapons and powerups!';
                    adReward = 'Reward: 25 RevCoins';
                    break;
                case 'continue':
                    adTitle = 'üõ°Ô∏è Continue Your Mission!';
                    adDescription = 'Watch an ad to continue with full health and keep all your progress!';
                    adReward = 'Reward: Full health restoration + keep all progress';
                    break;
            }
            
            adContent.innerHTML = `
                <h2 style="color: #00ffff; margin-bottom: 20px;">${adTitle}</h2>
                <p style="margin-bottom: 20px; line-height: 1.5;">${adDescription}</p>
                <p style="color: #ffff00; margin-bottom: 30px; font-weight: bold;">${adReward}</p>
                
                <div style="margin-bottom: 30px;">
                    <div style="background: #333; border-radius: 10px; padding: 20px; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; margin-bottom: 10px;">
                            <div style="width: 40px; height: 30px; background: #00ffff; border-radius: 5px; margin-right: 10px; display: flex; align-items: center; justify-content: center;">
                                <div style="width: 0; height: 0; border-left: 8px solid #000; border-top: 6px solid transparent; border-bottom: 6px solid transparent;"></div>
                            </div>
                            <p style="margin: 0; color: #888;">üì∫ Simulated Ad Playing...</p>
                        </div>
                        <div style="background: #555; height: 6px; border-radius: 3px; overflow: hidden;">
                            <div id="adProgress" style="background: linear-gradient(90deg, #00ffff, #0080ff); height: 100%; width: 0%; transition: width 0.1s linear;"></div>
                        </div>
                        <p id="adTime" style="margin: 5px 0 0 0; color: #888; font-size: 0.9em;">0:00 / 0:15</p>
                    </div>
                </div>
                
                <button id="watchAdBtn" style="
                    background: linear-gradient(45deg, #00ff00, #008000);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    cursor: pointer;
                    margin-right: 10px;
                ">Watch Ad</button>
                
                <button id="skipAdBtn" style="
                    background: linear-gradient(45deg, #ff4444, #cc0000);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    cursor: pointer;
                ">Skip</button>
            `;
            
            adModal.appendChild(adContent);
            document.body.appendChild(adModal);
            
            // Simulate ad watching
            let adProgress = 0;
            const adDuration = 15000; // 15 seconds
            const progressBar = document.getElementById('adProgress');
            const timeDisplay = document.getElementById('adTime');
            const watchBtn = document.getElementById('watchAdBtn');
            const skipBtn = document.getElementById('skipAdBtn');
            
            // Disable buttons during ad
            watchBtn.disabled = true;
            watchBtn.textContent = 'Watching...';
            watchBtn.style.background = 'linear-gradient(45deg, #666, #444)';
            skipBtn.disabled = true;
            skipBtn.textContent = 'Please Wait...';
            skipBtn.style.background = 'linear-gradient(45deg, #666, #444)';
            
            const adInterval = setInterval(() => {
                adProgress += 100; // Update every 100ms
                const progressPercent = (adProgress / adDuration) * 100;
                const currentTime = Math.floor(adProgress / 1000);
                const totalTime = Math.floor(adDuration / 1000);
                
                progressBar.style.width = progressPercent + '%';
                timeDisplay.textContent = `0:${currentTime.toString().padStart(2, '0')} / 0:${totalTime.toString().padStart(2, '0')}`;
                
                if (adProgress >= adDuration) {
                    clearInterval(adInterval);
                    
                    // Re-enable buttons
                    watchBtn.disabled = false;
                    watchBtn.textContent = 'Complete!';
                    watchBtn.style.background = 'linear-gradient(45deg, #00ff00, #008000)';
                    skipBtn.disabled = false;
                    skipBtn.textContent = 'Skip';
                    skipBtn.style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                    
                    // Auto-complete after 1 second
                    setTimeout(() => {
                        if (callback) callback();
                        document.body.removeChild(adModal);
                    }, 1000);
                }
            }, 100);
            
            // Add event listeners
            watchBtn.addEventListener('click', () => {
                if (!watchBtn.disabled) {
                    clearInterval(adInterval);
                    if (callback) callback();
                    document.body.removeChild(adModal);
                }
            });
            
            skipBtn.addEventListener('click', () => {
                clearInterval(adInterval);
                document.body.removeChild(adModal);
            });
            
            // Add CSS animation
         const style = document.createElement('style');
         style.textContent = `
                @keyframes progress {
                    from { width: 0%; }
                    to { width: 100%; }
             }
         `;
         document.head.appendChild(style);
         
            // Event listeners
            document.getElementById('watchAdBtn').addEventListener('click', () => {
                // Disable the watch ad button immediately
                const watchBtn = document.getElementById('watchAdBtn');
                watchBtn.disabled = true;
                watchBtn.textContent = 'Ad Playing...';
                watchBtn.style.background = 'linear-gradient(45deg, #888, #666)';
                
                simulateAdWatch(type, callback);
                document.body.removeChild(adModal);
            });
            
            document.getElementById('skipAdBtn').addEventListener('click', () => {
                document.body.removeChild(adModal);
            });
        }
        
        function simulateAdWatch(type, callback) {
            // Simulate ad loading and watching
            console.log(`üì∫ Ad started: ${type}`);
            
            setTimeout(() => {
                console.log(`‚úÖ Ad completed: ${type}`);
                adWatchCount++;
                adRevenue += 0.01; // $0.01 per ad view
                
                // Track ad metrics
                trackAdMetrics(type);
                
                // Execute callback
                if (callback) callback();
                
            }, 3000); // 3 second simulated ad
        }
        
        function trackAdMetrics(type) {
            // Track ad performance metrics
            const adMetrics = {
                type: type,
                timestamp: Date.now(),
                revenue: 0.01,
                userEngagement: Math.random() * 100
            };
            
            console.log('üìä Ad Metrics:', adMetrics);
            
            // Store in localStorage for analytics
            const metrics = JSON.parse(localStorage.getItem('adMetrics') || '[]');
            metrics.push(adMetrics);
            localStorage.setItem('adMetrics', JSON.stringify(metrics));
        }
        
        // Inventory Management Functions
        function addToInventory(type, itemId, itemData) {
            if (!inventory[type]) {
                inventory[type] = {};
            }
            
            if (!inventory[type][itemId]) {
                inventory[type][itemId] = {
                    count: 0,
                    data: itemData
                };
            }
            
            inventory[type][itemId].count++;
            console.log(`üì¶ Added to inventory: ${itemData.name} (${type})`);
        }
        
        function removeFromInventory(type, itemId) {
            if (inventory[type] && inventory[type][itemId]) {
                inventory[type][itemId].count--;
                if (inventory[type][itemId].count <= 0) {
                    delete inventory[type][itemId];
                }
                console.log(`üì¶ Removed from inventory: ${itemId} (${type})`);
            }
        }
        
        function getInventoryCount(type, itemId) {
            return inventory[type] && inventory[type][itemId] ? inventory[type][itemId].count : 0;
        }
        
        // Purchase Receipt Functions
        function addToReceipt(item, currency, amount) {
            purchaseReceipt.items.push({
                name: item.name,
                currency: currency,
                amount: amount,
                timestamp: Date.now()
            });
            
            if (currency === 'coins') {
                purchaseReceipt.totalCoins += amount;
            } else if (currency === 'revCoins') {
                purchaseReceipt.totalRevCoins += amount;
            }
        }
        
        function showPurchaseReceipt() {
            if (purchaseReceipt.items.length === 0) return;
            
            const receiptDiv = document.createElement('div');
            receiptDiv.id = 'purchaseReceipt';
            receiptDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #1a1a2e, #16213e);
                border: 2px solid #00ffff;
                border-radius: 15px;
                padding: 30px;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
                z-index: 3000;
                color: white;
                font-family: Arial, sans-serif;
            `;
            
            let receiptHTML = `
                <h2 style="color: #00ffff; text-align: center; margin-bottom: 20px;">üßæ Purchase Receipt</h2>
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #ffff00; margin-bottom: 10px;">Items Purchased:</h3>
            `;
            
            purchaseReceipt.items.forEach(item => {
                const currencyIcon = item.currency === 'coins' ? 'üí∞' : 'üíé';
                receiptHTML += `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                        <span>${item.name}</span>
                        <span>${currencyIcon} ${item.amount}</span>
                    </div>
                `;
            });
            
            receiptHTML += `
                </div>
                <div style="border-top: 1px solid #00ffff; padding-top: 15px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; font-weight: bold; font-size: 1.1em;">
                        <span>Total Coins:</span>
                        <span>üí∞ ${purchaseReceipt.totalCoins}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-weight: bold; font-size: 1.1em;">
                        <span>Total RevCoins:</span>
                        <span>üíé ${purchaseReceipt.totalRevCoins}</span>
                    </div>
                </div>
                <button onclick="closePurchaseReceipt()" style="
                    background: linear-gradient(45deg, #00ff00, #008000);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 5px;
                    font-weight: bold;
                    cursor: pointer;
                    width: 100%;
                ">Close Receipt</button>
            `;
            
            receiptDiv.innerHTML = receiptHTML;
            document.body.appendChild(receiptDiv);
        }
        
        function closePurchaseReceipt() {
            const receipt = document.getElementById('purchaseReceipt');
            if (receipt) {
                document.body.removeChild(receipt);
            }
            // Clear receipt after showing
            purchaseReceipt.items = [];
            purchaseReceipt.totalCoins = 0;
            purchaseReceipt.totalRevCoins = 0;
        }
        
        // Leaderboard and Stats Functions
        function updatePlayerStats() {
            playerStats.totalScore = Math.max(playerStats.totalScore, score);
            playerStats.totalCoins = Math.max(playerStats.totalCoins, coins);
            playerStats.totalRevCoins = Math.max(playerStats.totalRevCoins, revCoins);
            playerStats.totalLoyalty = Math.max(playerStats.totalLoyalty, loyalty);
            playerStats.highestWave = Math.max(playerStats.highestWave, currentWave);
            
            // Update inventory counts
            playerStats.shipsOwned = Object.values(ships).filter(ship => ship.owned).length;
            playerStats.weaponsOwned = Object.keys(inventory).length; // Count powerup types owned
            
            // Save to localStorage
            localStorage.setItem('playerStats', JSON.stringify(playerStats));
        }
        
        function getPlayerRank() {
            const playerScore = playerStats.totalScore;
            let rank = 1;
            
            for (let i = 0; i < leaderboard.length; i++) {
                if (playerScore >= leaderboard[i].score) {
                    return rank;
                }
                rank++;
            }
            
            return rank;
        }
        
        function updatePlayerRank() {
            const newRank = getPlayerRank();
            const oldRank = playerStats.currentRank;
            
            // Update rank change
            if (oldRank > 0 && newRank !== oldRank) {
                const rankChange = oldRank - newRank; // Positive = moved up, Negative = moved down
                playerStats.previousRank = oldRank;
                playerStats.currentRank = newRank;
                
                // Show rank change notification
                showRankChangeNotification(rankChange);
            } else if (oldRank === 0) {
                // First time setting rank
                playerStats.currentRank = newRank;
            }
        }
        
        function showRankChangeNotification(rankChange) {
            const notification = document.createElement('div');
            notification.id = 'rankChangeNotification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                border: 2px solid ${rankChange > 0 ? '#00ff00' : '#ff0000'};
                border-radius: 10px;
                padding: 15px 20px;
                color: white;
                font-size: 1.2em;
                font-weight: bold;
                z-index: 2000;
                animation: slideInRight 0.5s ease-out;
            `;
            
            const changeText = rankChange > 0 ? `+${rankChange}` : `${rankChange}`;
            const changeColor = rankChange > 0 ? '#00ff00' : '#ff0000';
            
            notification.innerHTML = `
                <div style="margin-bottom: 5px;">Rank Change</div>
                <div style="color: ${changeColor}; font-size: 1.5em;">${changeText}</div>
            `;
            
            // Add animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideInRight {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function showTutorial() {
            const tutorialDiv = document.createElement('div');
            tutorialDiv.id = 'tutorialModal';
            tutorialDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                color: white;
                font-family: Arial, sans-serif;
            `;
            
            tutorialDiv.innerHTML = `
                <div style="
                    background: linear-gradient(45deg, #1a1a2e, #16213e);
                    border: 3px solid #00ffff;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    text-align: center;
                ">
                    <h2 style="color: #00ffff; margin-bottom: 20px;">üéÆ HOW TO PLAY</h2>
                    
                    <div style="text-align: left; margin-bottom: 20px;">
                        <h3 style="color: #ffff00;">üéØ CONTROLS:</h3>
                        <p><strong>Desktop:</strong> Move mouse to control ship, click to shoot</p>
                        <p><strong>Mobile:</strong> Touch and drag to move ship, auto-fires</p>
                        <p><strong>Keyboard:</strong> Arrow keys or WASD to move, Space to shoot</p>
                    </div>
                    
                    <div style="text-align: left; margin-bottom: 20px;">
                        <h3 style="color: #ffff00;">‚ö° POWERUPS:</h3>
                        <p><strong>üõ°Ô∏è Shield:</strong> Blocks one hit</p>
                        <p><strong>üöÄ Speed:</strong> Increases movement speed</p>
                        <p><strong>‚öîÔ∏è Damage:</strong> Increases bullet damage</p>
                        <p><strong>üî• Rapid Fire:</strong> Faster shooting</p>
                        <p><strong>üéØ Multiple Shots:</strong> Shoot multiple bullets</p>
                        <p><strong>üß≤ Magnet:</strong> Attracts powerups and coins</p>
                        <p><strong>üîß Repair:</strong> Restores health</p>
                        <p><strong>üí• Piercing Laser:</strong> Shots go through enemies</p>
                        <p><strong>üí∞ Coin Boost:</strong> Earn more coins</p>
                    </div>
                    
                    <div style="text-align: left; margin-bottom: 20px;">
                        <h3 style="color: #ffff00;">üéØ OBJECTIVES:</h3>
                        <p>‚Ä¢ Destroy enemies to earn points and coins</p>
                        <p>‚Ä¢ Survive as many waves as possible</p>
                        <p>‚Ä¢ Collect powerups to enhance your ship</p>
                        <p>‚Ä¢ Defeat bosses every 5 waves</p>
                        <p>‚Ä¢ Build up your fleet in the shop</p>
                    </div>
                    
                    <div style="text-align: left; margin-bottom: 20px;">
                        <h3 style="color: #ffff00;">üíé REVIVES:</h3>
                        <p>‚Ä¢ You have 3 revives per game</p>
                        <p>‚Ä¢ Watch ads to continue when you die</p>
                        <p>‚Ä¢ After 3 revives, game ends and score is saved</p>
                    </div>
                    
                    <button onclick="closeTutorial()" style="
                        background: linear-gradient(45deg, #00ff00, #008000);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 1.1em;
                    ">GOT IT!</button>
                </div>
            `;
            
            document.body.appendChild(tutorialDiv);
        }
        
        function closeTutorial() {
            const tutorialModal = document.getElementById('tutorialModal');
            if (tutorialModal) {
                tutorialModal.remove();
            }
        }
        
        function showLeaderboard() {
            const leaderboardDiv = document.createElement('div');
            leaderboardDiv.id = 'leaderboardModal';
            leaderboardDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 3000;
            `;
            
            const playerRank = getPlayerRank();
            const playerReward = virtualRewards[playerRank] || null;
            
            let leaderboardHTML = `
                <div style="
                    background: linear-gradient(45deg, #1a1a2e, #16213e);
                    border: 3px solid #00ffff;
                    border-radius: 20px;
                    padding: 30px;
                    max-width: 800px;
                    max-height: 90vh;
                    overflow-y: auto;
                    color: white;
                    font-family: Arial, sans-serif;
                ">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <h1 style="color: #00ffff; font-size: 2.5em; margin-bottom: 10px;">üèÜ LEADERBOARD üèÜ</h1>
                        <div style="font-size: 1.2em; color: #ffff00; margin-bottom: 15px;">
                            Your Rank: #${playerRank} | Score: ${playerStats.totalScore.toLocaleString()}
                        </div>
                        <div style="
                            background: rgba(0, 255, 255, 0.1);
                            border: 1px solid #00ffff;
                            border-radius: 10px;
                            padding: 15px;
                            margin-bottom: 20px;
                            font-size: 0.9em;
                        ">
                            <div style="color: #ffff00; font-weight: bold; margin-bottom: 8px;">üíé REWARDS SYSTEM</div>
                            <div style="color: #fff; line-height: 1.4;">
                                <strong>üèÜ Monthly Rewards:</strong> Top 5 players receive virtual rewards at the end of each month.<br>
                                <strong>üìä Real-time Rankings:</strong> Leaderboard updates instantly as you play.<br>
                                <strong>üéØ Climb the Ranks:</strong> Higher scores = better rewards next month!
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 30px;">
                        <h2 style="color: #00ffff; text-align: center; margin-bottom: 20px;">üåü TOP 5 PLAYERS üåü</h2>
            `;
            
            // Top 5 players
            for (let i = 0; i < 5; i++) {
                const player = leaderboard[i];
                const reward = virtualRewards[i + 1];
                const isPlayerRank = (i + 1) === playerRank;
                
                leaderboardHTML += `
                    <div style="
                        background: ${isPlayerRank ? 'linear-gradient(45deg, #ffd700, #ffed4e)' : 'rgba(255,255,255,0.1)'};
                        border: 2px solid ${isPlayerRank ? '#ffd700' : '#00ffff'};
                        border-radius: 15px;
                        padding: 20px;
                        margin-bottom: 15px;
                        color: ${isPlayerRank ? '#000' : '#fff'};
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 15px;">
                                <div style="
                                    font-size: 2em;
                                    font-weight: bold;
                                    color: ${isPlayerRank ? '#ff6b35' : '#00ffff'};
                                ">${reward.badge}</div>
                                <div>
                                    <div style="font-size: 1.3em; font-weight: bold; margin-bottom: 5px;">
                                        #${i + 1} ${player.name}
                                    </div>
                                    <div style="font-size: 0.9em; opacity: 0.8;">
                                        Wave ${player.wave} | ${player.coins.toLocaleString()} Coins | ${player.achievements} Achievements
                                    </div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 5px;">
                                    ${player.score.toLocaleString()}
                                </div>
                                <div style="font-size: 0.9em; color: #00ff00;">
                                    ${reward.reward}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            leaderboardHTML += `
                    </div>
                    
                    <div style="margin-bottom: 30px;">
                        <h2 style="color: #00ffff; text-align: center; margin-bottom: 20px;">üéØ YOUR POSITION üéØ</h2>
                        <div style="
                            background: linear-gradient(45deg, #ff6b35, #ff8c42);
                            border: 2px solid #ff6b35;
                            border-radius: 15px;
                            padding: 20px;
                            color: #fff;
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <div style="
                                        font-size: 2em;
                                        font-weight: bold;
                                        color: #ffff00;
                                    ">üéÆ</div>
                                    <div>
                                        <div style="font-size: 1.3em; font-weight: bold; margin-bottom: 5px;">
                                            #${playerRank} RevEmpire
                                            ${playerStats.previousRank > 0 && playerStats.previousRank !== playerRank ? 
                                                `<span style="color: ${playerStats.previousRank > playerRank ? '#00ff00' : '#ff0000'}; font-size: 0.8em; margin-left: 10px;">
                                                    ${playerStats.previousRank > playerRank ? '+' : ''}${playerStats.previousRank - playerRank}
                                                </span>` : ''
                                            }
                                        </div>
                                        <div style="font-size: 0.9em; opacity: 0.8;">
                                            Wave ${playerStats.highestWave} | ${playerStats.totalCoins.toLocaleString()} Coins | ${playerStats.achievements.length} Achievements
                                        </div>
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 5px;">
                                        ${playerStats.totalScore.toLocaleString()}
                                    </div>
                                    <div style="font-size: 0.9em; color: #00ff00;">
                                        ${playerRank <= 5 ? virtualRewards[playerRank]?.reward || 'Keep climbing!' : 'Keep climbing!'}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 30px;">
                        <div style="
                            background: rgba(255, 255, 0, 0.1);
                            border: 1px solid #ffff00;
                            border-radius: 10px;
                            padding: 15px;
                            font-size: 0.9em;
                        ">
                            <div style="color: #ffff00; font-weight: bold; margin-bottom: 8px;">üìÖ REWARD SCHEDULE</div>
                            <div style="color: #fff; line-height: 1.4;">
                                <strong>üóìÔ∏è Monthly Reset:</strong> Leaderboard resets on the 1st of each month<br>
                                <strong>üí∞ Reward Distribution:</strong> Virtual rewards are credited to your account on the 2nd of each month<br>
                                <strong>üèÜ Eligibility:</strong> Must maintain top 5 position until month ends<br>
                                <strong>üìà Score Tracking:</strong> Your highest score of the month determines your rank
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <button onclick="closeLeaderboard()" style="
                            background: linear-gradient(45deg, #00ff00, #008000);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 1.1em;
                            font-weight: bold;
                            cursor: pointer;
                            margin-right: 10px;
                        ">Close</button>
                        <button onclick="showPlayerStats()" style="
                            background: linear-gradient(45deg, #00ffff, #0080ff);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 1.1em;
                            font-weight: bold;
                            cursor: pointer;
                        ">View My Stats</button>
                    </div>
                </div>
            `;
            
            leaderboardDiv.innerHTML = leaderboardHTML;
            document.body.appendChild(leaderboardDiv);
        }
        
        function closeLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }
        
        function showPlayerStats() {
            const statsDiv = document.createElement('div');
            statsDiv.id = 'playerStatsModal';
            statsDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 3000;
            `;
            
            const playerRank = getPlayerRank();
            const joinDate = new Date(playerStats.joinDate).toLocaleDateString();
            
            let statsHTML = `
                <div style="
                    background: linear-gradient(45deg, #1a1a2e, #16213e);
                    border: 3px solid #00ffff;
                    border-radius: 20px;
                    padding: 30px;
                    max-width: 900px;
                    max-height: 90vh;
                    overflow-y: auto;
                    color: white;
                    font-family: Arial, sans-serif;
                ">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <h1 style="color: #00ffff; font-size: 2.5em; margin-bottom: 10px;">üìä PLAYER STATS üìä</h1>
                        <div style="font-size: 1.2em; color: #ffff00;">
                            Rank: #${playerRank} | Joined: ${joinDate}
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                        <div style="background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px;">
                            <h3 style="color: #00ffff; margin-bottom: 15px;">üèÜ Achievements</h3>
                            <div style="margin-bottom: 10px;">
                                <span>Highest Score:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.totalScore.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Highest Wave:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.highestWave}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Total Enemies Destroyed:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.totalEnemiesDestroyed.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Total Bosses Defeated:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.totalBossesDefeated.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Powerups Collected:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.totalPowerupsCollected.toLocaleString()}</span>
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px;">
                            <h3 style="color: #00ffff; margin-bottom: 15px;">üí∞ Economy</h3>
                            <div style="margin-bottom: 10px;">
                                <span>Total Coins Earned:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.totalCoins.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Total RevCoins Earned:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.totalRevCoins.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Total Loyalty Earned:</span>
                                <span style="float: right; color: #ffff00;">$${playerStats.totalLoyalty.toFixed(6)}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Total Withdrawals:</span>
                                <span style="float: right; color: #ffff00;">$${playerStats.totalWithdrawals.toFixed(2)}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Current Wallet:</span>
                                <span style="float: right; color: #ffff00;">$${wallet.toFixed(6)}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                        <div style="background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px;">
                            <h3 style="color: #00ffff; margin-bottom: 15px;">üéÆ Gameplay</h3>
                            <div style="margin-bottom: 10px;">
                                <span>Games Played:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.gamesPlayed}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Total Play Time:</span>
                                <span style="float: right; color: #ffff00;">${Math.floor(playerStats.totalPlayTime / 60000)} minutes</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Ships Owned:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.shipsOwned}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Weapons Owned:</span>
                                <span style="float: right; color: #ffff00;">${playerStats.weaponsOwned}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Current Ship:</span>
                                <span style="float: right; color: #ffff00;">${ships[player.currentShip]?.name || 'None'}</span>
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px;">
                            <h3 style="color: #00ffff; margin-bottom: 15px;">üèÖ Current Status</h3>
                            <div style="margin-bottom: 10px;">
                                <span>Current Score:</span>
                                <span style="float: right; color: #ffff00;">${score.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Current Wave:</span>
                                <span style="float: right; color: #ffff00;">${currentWave}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Current Coins:</span>
                                <span style="float: right; color: #ffff00;">${coins.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Current RevCoins:</span>
                                <span style="float: right; color: #ffff00;">${revCoins.toLocaleString()}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <span>Current Loyalty:</span>
                                <span style="float: right; color: #ffff00;">$${loyalty.toFixed(6)}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <button onclick="closePlayerStats()" style="
                            background: linear-gradient(45deg, #00ff00, #008000);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 1.1em;
                            font-weight: bold;
                            cursor: pointer;
                            margin-right: 10px;
                        ">Close</button>
                        <button onclick="showLeaderboard()" style="
                            background: linear-gradient(45deg, #ff6b35, #ff8c42);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 1.1em;
                            font-weight: bold;
                            cursor: pointer;
                        ">View Leaderboard</button>
                    </div>
                </div>
            `;
            
            statsDiv.innerHTML = statsHTML;
            document.body.appendChild(statsDiv);
        }
        
        function closePlayerStats() {
            const modal = document.getElementById('playerStatsModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }
        
        function showDoubleEarningsAd() {
            if (adWatchedThisWave) {
                alert('You already watched an ad for this wave!');
                return;
            }
            
            // Disable the ad button immediately to prevent multiple clicks
            const adButton = document.getElementById('watchAdForDouble');
            adButton.disabled = true;
            adButton.textContent = 'Ad in Progress...';
            
            // Disable the continue button until ad completes
            const continueButton = document.getElementById('continueToNextLevel');
            if (continueButton) {
                continueButton.disabled = true;
                continueButton.textContent = 'Waiting for Ad...';
            }
            
            showAdModal('doubleEarnings', () => {
                // Debug: Log the values before doubling
                console.log(`üîç Double Earnings Debug: coinsEarnedThisWave=${coinsEarnedThisWave}, loyaltyEarnedThisWave=${loyaltyEarnedThisWave}`);
                
                // Double the earnings
                coins += coinsEarnedThisWave;
                loyaltyEarnings += loyaltyEarnedThisWave;
                loyalty += loyaltyEarnedThisWave; // Add to main loyalty balance
                wallet += loyaltyEarnedThisWave; // Add to wallet balance
                
                adWatchedThisWave = true;
                updateHUD();
                
                // Re-enable the continue button
                if (continueButton) {
                    continueButton.disabled = false;
                    continueButton.textContent = 'Continue to Next Level';
                }
                
                // Update ad button to show completed state
                adButton.textContent = '‚úÖ Earnings Doubled!';
                adButton.style.background = 'linear-gradient(45deg, #00ff00, #008000)';
                
                // Show reward message
                showRewardMessage(`üí∞ +${coinsEarnedThisWave} coins & $${loyaltyEarnedThisWave.toFixed(6)} earned!`);
            });
        }
        
        function showContinueAd() {
            console.log(`üîç Revive check: ${reviveCount}/${maxRevives}`);
            // Check if player has revives left
            if (reviveCount >= maxRevives) {
                console.log('‚ùå No more revives - game over!');
                // No more revives - game over
                submitScoreAndGameOver();
                return;
            }
            
            showAdModal('continue', () => {
                // Continue the player with full health and keep all progress
                health = 100;
                reviveCount++; // Increment revive count
                console.log(`‚úÖ Revive used: ${reviveCount}/${maxRevives}`);
                gameRunning = true;
                gamePaused = false;
                
                // Hide game over screen
                document.getElementById('gameOver').style.display = 'none';
                
                // Call restartGame to reset wave progress but keep everything else
                restartGame();
                
                showRewardMessage(`üõ°Ô∏è Mission continued! (${reviveCount}/${maxRevives} revives used)`);
            });
        }
        
        function showBonusCoinsAd() {
            showAdModal('bonusCoins', () => {
                // Give bonus coins
                coins += 100;
                updateHUD();
                
                showRewardMessage('üéÅ +100 bonus coins earned!');
            });
        }
        
        function showSpeedUpBuildAd() {
            // Check if there are any ships under construction
            const shipsInConstruction = Object.keys(shipsUnderConstruction);
            if (shipsInConstruction.length === 0) {
                alert('No ships are currently under construction!');
                return;
            }
            
            showAdModal('speedUpBuild', () => {
                // Speed up construction by 30 seconds per ad
                const speedUpTime = 30000; // 30 seconds
                
                for (let shipId in shipsUnderConstruction) {
                    const ship = ships[shipId];
                    ship.currentBuildTime -= speedUpTime;
                    
                    if (ship.currentBuildTime <= 0) {
                        // Ship is complete
                        ship.buildTime = 0;
                        ship.currentBuildTime = 0;
                        ship.destroyed = false;
                        delete shipsUnderConstruction[shipId];
                        showRewardMessage(`üöÄ ${ship.name} construction completed!`);
                    } else {
                        // Update remaining time
                        ship.buildTime = Date.now() + ship.currentBuildTime;
                    }
                }
                
                updateShopDisplay();
                updateHUD();
            });
        }
        
        function showRevCoinsAd() {
            const currentTime = Date.now();
            const timeSinceLastAd = currentTime - lastAdWatchTime;
            
            if (timeSinceLastAd < adCooldownTime) {
                const remainingTime = Math.ceil((adCooldownTime - timeSinceLastAd) / 1000 / 60);
                alert(`Ad cooldown active! Please wait ${remainingTime} more minutes before watching another ad for RevCoins.`);
                return;
            }
            
            showAdModal('revCoins', () => {
                // Give RevCoins
                revCoins += 25;
                lastAdWatchTime = currentTime;
                updateHUD();
                updatePremiumShopDisplay();
                
                showRewardMessage('üíé +25 RevCoins earned!');
            });
        }
        
        function updateReviveDisplay() {
            // This function is no longer needed since we changed to continue system
            // But keeping it to prevent errors if called
            console.log('Revive display update called - continuing with new system');
        }
        
        function showBossWarning() {
            // Initialize boss wave if this is the first boss
            if (bossWaveCount === 0) {
                bossWaveCount = 1;
                maxBossWaves = Math.floor(Math.random() * 5) + 1; // 1-5 bosses
                bossDefeatedCount = 0;
            }
            
            const warningDiv = document.createElement('div');
            warningDiv.id = 'bossWarning';
            warningDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #ff0000, #800000);
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                font-size: 2rem;
                font-weight: bold;
                text-align: center;
                z-index: 3000;
                border: 3px solid #ff4444;
                box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
                animation: bossWarningPulse 2s ease-in-out;
            `;
            
            let warningMessage = '';
            if (bossWaveCount === 1) {
                warningMessage = `
                    <div style="font-size: 3rem; margin-bottom: 20px;">üö®</div>
                    <div>BOSS INCOMING!</div>
                    <div style="font-size: 1.5rem; margin-top: 10px; color: #ffcccc;">Prepare for battle!</div>
                `;
            } else {
                warningMessage = `
                    <div style="font-size: 3rem; margin-bottom: 20px;">üò±</div>
                    <div>OH NO! ANOTHER BOSS!</div>
                    <div style="font-size: 1.5rem; margin-top: 10px; color: #ffcccc;">Boss ${bossWaveCount} of ${maxBossWaves}</div>
                `;
            }
            
            warningDiv.innerHTML = warningMessage;
            
            // Add animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossWarningPulse {
                    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(warningDiv);
            
            // Remove warning after 3 seconds
            setTimeout(() => {
                if (warningDiv.parentNode) {
                    warningDiv.parentNode.removeChild(warningDiv);
                }
                spawnBoss();
            }, 3000);
        }
        
        function spawnBoss() {
            // Determine which boss to spawn based on wave
            let bossType;
            if (currentWave <= 10) {
                bossType = 'boss1';
            } else if (currentWave <= 20) {
                bossType = 'boss2';
            } else {
                bossType = 'boss3';
            }
            
            const bossTemplate = bossTypes[bossType];
            
            // Generate random boss stats for NFT-style uniqueness
            const randomBoss = generateRandomBossStats(bossTemplate);
            
            // Generate random shield configuration
            const shieldConfig = generateBossShieldConfig(randomBoss.maxPhase);
            
            const boss = {
                ...randomBoss,
                x: canvas.width / 2 - randomBoss.width / 2,
                y: -randomBoss.height,
                id: Date.now(),
                type: bossType,
                shields: shieldConfig.shields,
                maxShields: shieldConfig.maxShields,
                currentShieldIndex: 0,
                totalShieldHealth: shieldConfig.totalShieldHealth,
                remainingShieldHealth: shieldConfig.totalShieldHealth
            };
            
            // Log boss difficulty and rewards
            console.log(`üö® Boss spawned: ${boss.name} | Difficulty: ${calculateBossDifficultyMultiplier(boss).toFixed(2)}x | Rewards: ${boss.reward.coins} coins, $${boss.reward.loyalty.toFixed(6)} loyalty`);
            
            currentBoss = boss;
            bossActive = true;
            bossWarningShown = true;
            
            console.log(`üö® Boss spawned: ${boss.name} with ${boss.shields.length} shields (${boss.totalShieldHealth} shield HP)`);
        }
        
        function generateBossShieldConfig(maxPhase) {
            // Random shield configuration - 30% chance of no shields, 70% chance of 1 to maxPhase-1 shields
            const hasShields = Math.random() < 0.7;
            
            if (!hasShields) {
                return {
                    shields: [],
                    maxShields: 0,
                    totalShieldHealth: 0
                };
            }
            
            const shieldCount = Math.floor(Math.random() * (maxPhase - 1)) + 1; // 1 to maxPhase-1 shields
            const shields = [];
            let totalShieldHealth = 0;
            
            for (let i = 0; i < shieldCount; i++) {
                // Each shield has 50-150 HP, increasing with boss difficulty
                const shieldHP = Math.floor(Math.random() * 100) + 50 + (maxPhase * 10);
                shields.push({
                    maxHealth: shieldHP,
                    health: shieldHP,
                    color: getShieldColor(i, shieldCount)
                });
                totalShieldHealth += shieldHP;
            }
            
            return {
                shields: shields,
                maxShields: shieldCount,
                totalShieldHealth: totalShieldHealth
            };
        }
        
        function getShieldColor(index, totalShields) {
            // Different shield colors based on position and total count
            const colors = ['#0088ff', '#00aaff', '#00ccff', '#00eeff', '#00ffff'];
            return colors[index % colors.length];
        }
        
        function generateRandomBossStats(bossTemplate) {
            // Generate random variations of boss stats for NFT-style uniqueness
            const variation = 0.2; // 20% variation
            
            const randomBoss = {
                ...bossTemplate,
                health: Math.floor(bossTemplate.health * (0.8 + Math.random() * 0.4)), // ¬±20% health
                maxHealth: Math.floor(bossTemplate.maxHealth * (0.8 + Math.random() * 0.4)),
                damage: Math.floor(bossTemplate.damage * (0.8 + Math.random() * 0.4)), // ¬±20% damage
                fireRate: Math.floor(bossTemplate.fireRate * (0.8 + Math.random() * 0.4)), // ¬±20% fire rate
                speed: bossTemplate.speed * (0.8 + Math.random() * 0.4), // ¬±20% speed
                minionSpawnRate: Math.floor(bossTemplate.minionSpawnRate * (0.8 + Math.random() * 0.4)) // ¬±20% spawn rate
            };
            
            // Calculate dynamic rewards based on difficulty
            const difficultyMultiplier = calculateBossDifficultyMultiplier(randomBoss);
            randomBoss.reward = {
                coins: Math.floor(bossTemplate.reward.coins * difficultyMultiplier),
                loyalty: bossTemplate.reward.loyalty * difficultyMultiplier
            };
            
            return randomBoss;
        }
        
        function calculateBossDifficultyMultiplier(boss) {
            // Base difficulty from boss type (1-3)
            let difficulty = 1;
            if (boss.type === 'boss2') difficulty = 2;
            if (boss.type === 'boss3') difficulty = 3;
            
            // Health multiplier (higher health = harder)
            const healthMultiplier = boss.health / 500; // Normalized to base health
            
            // Damage multiplier (higher damage = harder)
            const damageMultiplier = boss.damage / 30; // Normalized to base damage
            
            // Fire rate multiplier (faster firing = harder)
            const fireRateMultiplier = 2000 / boss.fireRate; // Inverted (lower fireRate = faster = harder)
            
            // Speed multiplier (faster = harder)
            const speedMultiplier = boss.speed / 1.0; // Normalized to base speed
            
            // Shield multiplier (more shields = harder)
            const shieldMultiplier = boss.shields ? (1 + (boss.shields.length * 0.3)) : 1; // +30% per shield
            
            // Calculate total difficulty multiplier
            const totalMultiplier = (difficulty + healthMultiplier + damageMultiplier + fireRateMultiplier + speedMultiplier + shieldMultiplier) / 6;
            
            // Ensure minimum and maximum bounds
            return Math.max(0.5, Math.min(4.0, totalMultiplier));
        }
        
        function updateBoss() {
            if (!currentBoss) return;
            
            // Move boss down to screen
            if (currentBoss.y < 50) {
                currentBoss.y += 1;
            }
            
            // Boss movement pattern
            const centerX = canvas.width / 2 - currentBoss.width / 2;
            const time = Date.now() * 0.001;
            currentBoss.x = centerX + Math.sin(time * 0.5) * 100;
            
            // Boss firing
            if (Date.now() - currentBoss.lastFireTime > currentBoss.fireRate) {
                fireBossWeapon();
                currentBoss.lastFireTime = Date.now();
            }
            
            // Boss minion spawning
            if (Date.now() - currentBoss.lastMinionSpawn > currentBoss.minionSpawnRate) {
                spawnBossMinion();
                currentBoss.lastMinionSpawn = Date.now();
            }
            
            // Check boss phase transitions (now handled by shield destruction)
            // Additional phase transitions based on health percentage for bosses without shields
            if (!currentBoss.shields || currentBoss.shields.length === 0) {
                const healthPercent = currentBoss.health / currentBoss.maxHealth;
                const newPhase = Math.ceil((1 - healthPercent) * currentBoss.maxPhase) + 1;
                
                if (newPhase > currentBoss.phase && newPhase <= currentBoss.maxPhase) {
                    currentBoss.phase = newPhase;
                    currentBoss.fireRate = Math.max(500, currentBoss.fireRate - 200); // Faster firing
                    currentBoss.minionSpawnRate = Math.max(2000, currentBoss.minionSpawnRate - 1000); // Spawn minions faster
                    showBossPhaseTransition();
                }
            }
            
            // Check if boss is defeated
            if (currentBoss.health <= 0) {
                defeatBoss();
            }
        }
        
        function fireBossWeapon() {
            if (!currentBoss) return;
            
            // Create boss bullets
            const bulletCount = currentBoss.phase; // More bullets in higher phases
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = (Math.PI * 2 * i) / bulletCount;
                const bullet = {
                    x: currentBoss.x + currentBoss.width / 2,
                    y: currentBoss.y + currentBoss.height,
                    width: 8,
                    height: 8,
                    speed: 3,
                    damage: currentBoss.damage,
                    color: currentBoss.color,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3 + 2,
                    isBossBullet: true
                };
                bullets.push(bullet);
            }
        }
        
        function fireEnemyWeapon(enemy) {
            if (!enemy) return;
            
            let bullet;
            
            switch(enemy.ai) {
                case 'straight_shooter':
                    // Shoot straight down
                    bullet = {
                        x: enemy.x + enemy.width / 2 - 2,
                        y: enemy.y + enemy.height,
                        width: 4,
                        height: 8,
                        speed: 4,
                        damage: enemy.damage,
                        color: enemy.color,
                        vy: 4,
                        vx: 0,
                        isEnemyBullet: true
                    };
                    break;
                    
                case 'aimed_shooter':
                    // Shoot toward player
                    const dx = (player.x + player.width / 2) - (enemy.x + enemy.width / 2);
                    const dy = (player.y + player.height / 2) - (enemy.y + enemy.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    bullet = {
                        x: enemy.x + enemy.width / 2 - 2,
                        y: enemy.y + enemy.height,
                        width: 4,
                        height: 8,
                        speed: 3,
                        damage: enemy.damage,
                        color: enemy.color,
                        vx: distance > 0 ? (dx / distance) * 3 : 0,
                        vy: distance > 0 ? (dy / distance) * 3 : 3,
                        isEnemyBullet: true
                    };
                    break;
                    
                case 'kamikaze':
                    // Shoot in random direction (kamikaze enemies focus on collision)
                    const angle = Math.random() * Math.PI * 2;
                    bullet = {
                        x: enemy.x + enemy.width / 2 - 2,
                        y: enemy.y + enemy.height,
                        width: 4,
                        height: 8,
                        speed: 2,
                        damage: enemy.damage,
                        color: enemy.color,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2 + 1,
                        isEnemyBullet: true
                    };
                    break;
            }
            
            if (bullet) {
                bullets.push(bullet);
            }
        }
        
        function showBossPhaseTransition() {
            const phaseDiv = document.createElement('div');
            phaseDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #ff8800, #ff4400);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 1.5rem;
                font-weight: bold;
                text-align: center;
                z-index: 2000;
                border: 2px solid #ffaa00;
                box-shadow: 0 0 30px rgba(255, 136, 0, 0.5);
            `;
            phaseDiv.textContent = `PHASE ${currentBoss.phase}!`;
            
            document.body.appendChild(phaseDiv);
            
            setTimeout(() => {
                if (phaseDiv.parentNode) {
                    phaseDiv.parentNode.removeChild(phaseDiv);
                }
            }, 2000);
        }
        
        function spawnBossMinion() {
            if (!currentBoss) return;
            
            // Determine minion type based on boss phase
            const minionTypes = ['fighter', 'interceptor', 'destroyer'];
            const minionType = minionTypes[Math.floor(Math.random() * minionTypes.length)];
            const minionTemplate = enemyTypes[minionType];
            
            // Spawn minion from boss position
            const minion = {
                ...minionTemplate,
                x: currentBoss.x + Math.random() * currentBoss.width,
                y: currentBoss.y + currentBoss.height,
                id: Date.now() + Math.random(),
                type: minionType,
                isBossMinion: true,
                canShoot: true, // Boss minions can always shoot
                lastFireTime: Date.now()
            };
            
            enemies.push(minion);
            console.log(`üöÄ Boss spawned ${minion.name} minion`);
        }
        
        function defeatBoss() {
            if (!currentBoss) return;
            
            // Give boss rewards
            coins += currentBoss.reward.coins;
            loyaltyEarnings += currentBoss.reward.loyalty;
            totalWallet += currentBoss.reward.loyalty;
            coinsEarnedThisWave += currentBoss.reward.coins;
            loyaltyEarnedThisWave += currentBoss.reward.loyalty;
            
            // Create boss explosion
            for (let i = 0; i < 20; i++) {
                createExplosion(
                    currentBoss.x + Math.random() * currentBoss.width,
                    currentBoss.y + Math.random() * currentBoss.height
                );
            }
            
            bossDefeatedCount++;
            
            // Update player stats
            playerStats.totalBossesDefeated++;
            updatePlayerStats();
            
            // Check if there are more bosses in this wave
            if (bossDefeatedCount < maxBossWaves) {
                // More bosses coming
                showRewardMessage(`üéâ BOSS ${bossDefeatedCount} DEFEATED! +${currentBoss.reward.coins} coins`);
                
                // Reset current boss but keep wave active
                currentBoss = null;
                bossActive = false;
                bossWarningShown = false;
                
                // Spawn next boss after delay
                setTimeout(() => {
                    bossWaveCount++;
                    showBossWarning();
                }, 3000);
            } else {
                // All bosses defeated
                const totalBossesDefeated = maxBossWaves;
                showRewardMessage(`üéâ ALL BOSSES DEFEATED! +${currentBoss.reward.coins} coins`);
                
                // Reset all boss state
                currentBoss = null;
                bossActive = false;
                bossWarningShown = false;
                bossWaveCount = 0;
                maxBossWaves = 0; // Set to 0 to indicate no more bosses
                bossDefeatedCount = 0;
                
                // Show completion message
                setTimeout(() => {
                    showRewardMessage(`üèÜ GREAT JOB! You defeated ${totalBossesDefeated} boss(es)!`);
                }, 1000);
                
                // Continue to next wave
                setTimeout(() => {
                    if (gameRunning && !levelCompleteMenuShouldBeShown) {
                        showLevelCompleteMenu();
                    }
                }, 4000);
            }
        }
        
        function showRewardMessage(message) {
            const rewardDiv = document.createElement('div');
            rewardDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #00ff00, #008000);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 1.2rem;
                font-weight: bold;
                z-index: 2001;
                animation: fadeInOut 3s ease-in-out;
            `;
            rewardDiv.textContent = message;
            
            // Add animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(rewardDiv);
            
            setTimeout(() => {
                document.body.removeChild(rewardDiv);
            }, 3000);
        }
        
        function updateHUD() {
            // Update all HUD elements
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = currentWave;
            
            // Update wave display (simple, no difficulty indicator)
            document.getElementById('wave').textContent = currentWave;
            
            const healthPercent = Math.max(0, Math.min(100, health));
            document.getElementById('healthPercent').textContent = healthPercent + '%';
            document.getElementById('healthBar').style.width = healthPercent + '%';
            
            const progressPercent = Math.min(100, (enemiesKilledThisWave / enemiesRequiredForLevel) * 100);
            document.getElementById('progressPercent').textContent = Math.round(progressPercent) + '%';
            const waveProgress = document.getElementById('waveProgress');
            if (waveProgress) {
                waveProgress.style.width = progressPercent + '%';
            }
            
            document.getElementById('coins').textContent = coins;
            document.getElementById('empireCoins').textContent = empireCoins;
            document.getElementById('enemiesLeft').textContent = enemies.length;
            document.getElementById('earnings').textContent = '$' + loyalty.toFixed(6);
            document.getElementById('wallet').textContent = '$' + wallet.toFixed(6);
            document.getElementById('revCoins').textContent = revCoins;
            document.getElementById('revives').textContent = `${reviveCount}/${maxRevives}`;
            document.getElementById('comboDisplay').textContent = `x${comboMultiplier}`;
            
            // Show damaged ship warning if using damaged ship
            const currentShipData = ships[player.currentShip];
            if (currentShipData && currentShipData.destroyed) {
                // Create or update damaged ship warning
                let damagedWarning = document.getElementById('damagedShipWarning');
                if (!damagedWarning) {
                    damagedWarning = document.createElement('div');
                    damagedWarning.id = 'damagedShipWarning';
                    damagedWarning.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(255, 68, 68, 0.9);
                        border: 2px solid #ff0000;
                        border-radius: 10px;
                        padding: 10px 20px;
                        color: white;
                        font-weight: bold;
                        z-index: 1000;
                        text-align: center;
                        animation: pulse 1s infinite;
                    `;
                    document.body.appendChild(damagedWarning);
                }
                damagedWarning.innerHTML = `‚ö†Ô∏è DAMAGED SHIP - Reduced Performance ‚ö†Ô∏è`;
                damagedWarning.style.display = 'block';
            } else {
                // Hide damaged ship warning
                const damagedWarning = document.getElementById('damagedShipWarning');
                if (damagedWarning) {
                    damagedWarning.style.display = 'none';
                }
            }
            
            // Update withdrawal button state
            const withdrawBtn = document.getElementById('withdrawBtn');
            if (withdrawBtn) {
                if (wallet >= 5.00) {
                    withdrawBtn.disabled = false;
                    withdrawBtn.textContent = 'üí≥ Withdraw ($' + wallet.toFixed(2) + ')';
                } else {
                    withdrawBtn.disabled = true;
                    withdrawBtn.textContent = 'üí≥ Withdraw (Min $5.00)';
                }
            }
            
            // Update player stats and rank
            updatePlayerStats();
            updatePlayerRank();
            
            // Update rank display
            updateRankDisplay();
        }
        
        // Helper functions for damage levels
        function getDamageLevel(currentHealth, maxHealth) {
            const healthPercent = Math.floor((currentHealth / maxHealth) * 100);
            
            if (healthPercent >= 80) {
                return 'Slightly Damaged';
            } else if (healthPercent >= 70) {
                return 'Mildly Damaged';
            } else if (healthPercent >= 60) {
                return 'Moderately Damaged';
            } else if (healthPercent >= 1) {
                return 'Heavily Damaged';
            } else {
                return 'Destroyed';
            }
        }
        
        function getDamageColor(currentHealth, maxHealth) {
            const healthPercent = Math.floor((currentHealth / maxHealth) * 100);
            
            if (healthPercent >= 80) {
                return '#ffff00'; // Yellow
            } else if (healthPercent >= 70) {
                return '#ffaa00'; // Orange
            } else if (healthPercent >= 60) {
                return '#ff8800'; // Dark Orange
            } else if (healthPercent >= 1) {
                return '#ff4444'; // Red
            } else {
                return '#ff0000'; // Bright Red
            }
        }
        
        function updateRankDisplay() {
            const currentRank = getPlayerRank();
            const rankChange = playerStats.previousRank > 0 ? playerStats.previousRank - currentRank : 0;
            
            // Create or update rank display container
            let rankContainer = document.getElementById('rankDisplayContainer');
            if (!rankContainer) {
                rankContainer = document.createElement('div');
                rankContainer.id = 'rankDisplayContainer';
                rankContainer.style.cssText = `
                    position: fixed;
                    top: 50%;
                    right: 20px;
                    transform: translateY(-50%);
                    background: rgba(0, 0, 0, 0.7);
                    border: 2px solid #00ffff;
                    border-radius: 15px;
                    padding: 20px;
                    color: white;
                    font-family: Arial, sans-serif;
                    z-index: 1000;
                    min-width: 150px;
                    text-align: center;
                `;
                document.body.appendChild(rankContainer);
            }
            
            let changeText = '';
            let changeColor = '#ffffff';
            
            if (rankChange > 0) {
                changeText = `+${rankChange}`;
                changeColor = '#00ff00';
            } else if (rankChange < 0) {
                changeText = `${rankChange}`;
                changeColor = '#ff0000';
            }
            
            rankContainer.innerHTML = `
                <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 10px; color: #00ffff;">
                    RANK
                </div>
                <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px;">
                    #${currentRank}
                </div>
                <div style="font-size: 1em; color: #ffff00; margin-bottom: 10px;">
                    RevEmpire
                </div>
                ${changeText ? `
                    <div style="font-size: 1.5em; font-weight: bold; color: ${changeColor};">
                        ${changeText}
                    </div>
                ` : ''}
            `;
        }
        
                function showLevelCompleteMenu() {
            // Only show if we actually completed a level (enemies killed >= required)
            if (enemiesKilledThisWave < enemiesRequiredForLevel) {
                return;
            }
            
            gamePaused = true;
            levelCompleteMenuShouldBeShown = true;
            
            document.getElementById('completedWave').textContent = currentWave;
            document.getElementById('enemiesDefeated').textContent = enemiesKilledThisWave;
            document.getElementById('coinsEarned').textContent = coinsEarnedThisWave;
            document.getElementById('loyaltyEarned').textContent = '$' + loyaltyEarnedThisWave.toFixed(6);
            
            // Reset ad state for new wave
            adWatchedThisWave = false;
            
            // Enable/disable ad button based on earnings and ad state
            const adButton = document.getElementById('watchAdForDouble');
            if (adWatchedThisWave) {
                adButton.disabled = true;
                adButton.textContent = '‚úÖ Earnings Doubled!';
                adButton.style.background = 'linear-gradient(45deg, #00ff00, #008000)';
            } else if (coinsEarnedThisWave > 0 || loyaltyEarnedThisWave > 0) {
                adButton.disabled = false;
                adButton.textContent = 'Watch Ad to Double Earnings';
                adButton.style.background = 'linear-gradient(45deg, #ffaa00, #ff8800)';
            } else {
                adButton.disabled = true;
                adButton.textContent = 'No Earnings to Double';
                adButton.style.background = 'linear-gradient(45deg, #888, #666)';
            }
            
            document.getElementById('levelComplete').style.display = 'block';
        }
        
        function continueToNextLevel() {
            // Update player stats before resetting
            playerStats.gamesPlayed++;
            updatePlayerStats();
            
            console.log(`Continuing to level ${currentWave + 1}`);
            currentWave++;
            enemiesKilledThisWave = 0;
            coinsEarnedThisWave = 0;
            loyaltyEarnedThisWave = 0; // Reset after double earnings ad is handled
            levelCompleteMenuShouldBeShown = false;
            
            // Reset ad state for next wave
            adWatchedThisWave = false;
            
            enemies = [];
            bullets = [];
            
            enemiesRequiredForLevel = Math.floor(30 * Math.pow(1.1, currentWave - 1));
            
                 document.getElementById('levelComplete').style.display = 'none';
            
            // üöÄ Cool wave transition effect
            const waveTransition = document.createElement('div');
            waveTransition.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 255, 255, 0.9);
                color: #000;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 2rem;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            `;
            waveTransition.innerHTML = `üöÄ WAVE ${currentWave} üöÄ<br><small>Prepare for battle!</small>`;
            document.getElementById('gameContainer').appendChild(waveTransition);
            
            // Remove transition after 2 seconds and start game
                 setTimeout(() => {
                document.getElementById('gameContainer').removeChild(waveTransition);
                gamePaused = false;
                gameLoop();
            }, 2000);
        }
        
        function gameOver() {
            gameRunning = false;
            playGameOverSound();
            
            // Damage the current ship when player dies (but don't destroy it completely)
            const currentShipData = ships[player.currentShip];
            if (currentShipData && !currentShipData.destroyed) {
                // Reduce ship health by 25% when player dies
                const damageAmount = Math.floor(currentShipData.maxHealth * 0.25);
                currentShipData.health = Math.max(0, currentShipData.health - damageAmount);
                
                // Only mark as destroyed if health reaches 0
                if (currentShipData.health <= 0) {
                    currentShipData.destroyed = true;
                    currentShipData.health = 0;
                    console.log(`üí• Ship ${currentShipData.name} has been destroyed! Must buy new ship.`);
                    showRewardMessage(`üí• ${currentShipData.name} has been destroyed! You'll need to buy a new one.`);
                } else {
                    console.log(`üö® Ship ${currentShipData.name} has been damaged! Health: ${currentShipData.health}/${currentShipData.maxHealth}`);
                    showRewardMessage(`üö® ${currentShipData.name} has been damaged! Use nanobot repair kit to fix it.`);
                }
            }
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalWave').textContent = currentWave;
            updateReviveDisplay();
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function submitScoreAndGameOver() {
            console.log('üöÄ GAME OVER - Resetting to level 1');
            
            // Show final game over screen
            const gameOverScreen = document.getElementById('gameOver');
            gameOverScreen.innerHTML = `
                <h2>üèÜ GAME OVER</h2>
                <p>Final Score: <span id="finalScore">${score}</span></p>
                <p>Wave Reached: <span id="finalWave">${currentWave}</span></p>
                <p>Enemies Defeated: <span>${enemiesKilled}</span></p>
                <p>Coins Earned: <span>${coins}</span></p>
                <p>Loyalty Earned: <span>$${loyalty.toFixed(6)}</span></p>
                
                <div style="margin: 20px 0; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px; border: 1px solid #00ffff;">
                    <h3 style="color: #00ffff; margin-bottom: 10px;">üéØ Great Run!</h3>
                    <p style="margin-bottom: 15px; font-size: 0.9rem;">Your score has been saved to the leaderboard!</p>
                </div>
                
                <button onclick="restartFromLevel1()" style="
                    background: linear-gradient(45deg, #00ff00, #008000);
                    color: white;
                    border: none;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 1.1em;
                    margin-right: 10px;
                ">üöÄ NEW GAME</button>
                
                <button onclick="showLeaderboard()" style="
                    background: linear-gradient(45deg, #ffff00, #ff8800);
                    color: black;
                    border: none;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 1.1em;
                ">üèÜ LEADERBOARD</button>
            `;
            
            gameOverScreen.style.display = 'block';
        }
        
        function restartFromLevel1() {
            // Simple reset to level 1
            score = 0;
            coins = 0;
            health = 100;
            currentWave = 1;
            enemiesRequiredForLevel = 30;
            enemiesKilled = 0;
            enemiesKilledThisWave = 0;
            coinsEarnedThisWave = 0;
            loyaltyEarnedThisWave = 0;
            reviveCount = 0;
            
            // Reset all powerups
            activePowerups = {
                shield: { charges: 0, maxCharges: 5 },
                speed: null,
                damage: null,
                rapidFire: null,
                multipleShots: null,
                magnet: { active: false, endTime: 0, level: 0, pullRadius: 0, pullStrength: 0 },
                droneAlly: null,
                nanobotRepair: null,
                piercingLaser: { active: false, shotsRemaining: 0 },
                coinBoost: null
            };
            
            // Reset active powerup counts
            for (let key in activePowerupCounts) {
                activePowerupCounts[key] = 0;
            }
            
            // Clear all game objects
            bullets = [];
            enemies = [];
            powerups = [];
            explosions = [];
            seekingMissiles = [];
            missileExplosions = [];
            particles = [];
            
            // Reset player position
            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height - player.height - 50;
            
            // Reset boss state
            bossActive = false;
            currentBoss = null;
            bossWarningShown = false;
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Start fresh game
            gameRunning = true;
            gamePaused = false;
            gameStartTime = Date.now();
            
            // Restart game loop
            gameLoop();
            
            showRewardMessage('üöÄ New game started! Good luck!');
        }
        
                function updateShopDisplay() {
            // Update currency displays
            document.getElementById('hangarCoins').textContent = coins;
            document.getElementById('hangarRevCoins').textContent = revCoins;
            
            // Update ship list
            const shipList = document.getElementById('shipList');
            shipList.innerHTML = '';
            
            // Check if any ships are under construction and update their progress
            let hasShipsUnderConstruction = false;
            for (let shipId in ships) {
                const ship = ships[shipId];
                if (ship.owned && ship.buildTime > Date.now()) {
                    hasShipsUnderConstruction = true;
                    break;
                }
            }
            
            // If ships are under construction, schedule next update
            if (hasShipsUnderConstruction) {
                setTimeout(updateShopDisplay, 1000); // Update every second
            }
            
            // Check for completed ships and remove them from construction
            for (let shipId in shipsUnderConstruction) {
                const ship = ships[shipId];
                if (ship.buildTime <= Date.now()) {
                    // Ship construction completed
                    delete shipsUnderConstruction[shipId];
                    ship.buildTime = 0;
                    ship.currentBuildTime = 0;
                    ship.destroyed = false;
                    showRewardMessage(`üöÄ ${ship.name} construction completed!`);
                }
            }
            
            for (let shipId in ships) {
                const ship = ships[shipId];
                const shipDiv = document.createElement('div');
                shipDiv.className = 'shop-item';
                
                if (ship.owned) {
                    if (ship.destroyed) {
                        shipDiv.innerHTML = `
                            <span>${ship.name} (Destroyed)</span>
                            <button onclick="repairShip(${shipId})">Repair (${ship.repairCost} coins)</button>
                        `;
                    } else if (shipsUnderConstruction[shipId]) {
                        const remainingTime = Math.max(0, ship.buildTime - Date.now());
                        const timePercent = Math.max(0, (remainingTime / ship.baseBuildTime) * 100);
                        shipDiv.innerHTML = `
                            <span>${ship.name} (Under Construction)</span>
                            <div style="width: 100%; background: #333; border-radius: 5px; margin: 5px 0;">
                                <div style="width: ${100 - timePercent}%; height: 20px; background: #00ff00; border-radius: 5px; transition: width 0.3s;"></div>
                            </div>
                            <span>Time remaining: ${Math.ceil(remainingTime / 1000)}s</span>
                        `;
                    } else {
                        const isCurrentShip = player.currentShip == shipId;
                        shipDiv.innerHTML = `
                            <span>${ship.name} (Owned)</span>
                            <button onclick="selectShip(${shipId})" ${isCurrentShip ? 'disabled' : ''}>
                                ${isCurrentShip ? 'CURRENT SHIP' : 'SELECT SHIP'}
                            </button>
                        `;
                    }
                } else {
                    shipDiv.innerHTML = `
                        <span>${ship.name} - Level ${ship.level}</span>
                        <button onclick="buyShip(${shipId})">Buy (${ship.price} coins)</button>
                    `;
                }
                
                shipList.appendChild(shipDiv);
            }
            
            // Update shipyard list
            const shipyardList = document.getElementById('shipyardList');
            shipyardList.innerHTML = '';
            
            for (let shipId in ships) {
                const ship = ships[shipId];
                if (ship.owned) {
                    const shipDiv = document.createElement('div');
                    shipDiv.className = 'shop-item';
                    
                    let statusText = '';
                    let statusColor = '';
                    
                    if (ship.destroyed) {
                        const repairKitsAvailable = inventory.nanobotRepair ? inventory.nanobotRepair.owned : 0;
                        statusText = `üö® DAMAGED - Needs Nanobot Repair Kit (${repairKitsAvailable} available)`;
                        statusColor = '#ff4444';
                    } else if (ship.buildTime > Date.now()) {
                        const remainingTime = Math.max(0, ship.buildTime - Date.now());
                        const timePercent = Math.max(0, (remainingTime / ship.baseBuildTime) * 100);
                        statusText = `üî® Under Construction - ${Math.ceil(remainingTime / 1000)}s remaining`;
                        statusColor = '#ffaa00';
                    } else {
                        // Check if ship has reduced health
                        const healthPercent = Math.floor((ship.health / ship.maxHealth) * 100);
                        if (healthPercent < 100) {
                            const repairKitsAvailable = inventory.nanobotRepair ? inventory.nanobotRepair.owned : 0;
                            statusText = `‚ö†Ô∏è ${getDamageLevel(ship.health, ship.maxHealth)} - ${healthPercent}% Health\nUse Nanobot Repair Kit to restore to 100% (${repairKitsAvailable} available)`;
                            statusColor = getDamageColor(ship.health, ship.maxHealth);
                        } else {
                            statusText = '‚úÖ Fully Functional 100%';
                            statusColor = '#00ff00';
                        }
                    }
                    
                    shipDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div>
                                <span style="font-weight: bold;">${ship.name}</span>
                                <div style="color: ${statusColor}; font-size: 0.9em; margin-top: 2px;">${statusText}</div>
                            </div>
                            <div style="text-align: right;">
                                ${ship.destroyed ? `<button onclick="buyShip(${shipId})" style="background: #ff4444;">üí• DESTROYED - Buy New Ship</button>` : ''}
                                ${!ship.destroyed && ship.health < ship.maxHealth ? `<button onclick="repairShip(${shipId})" style="background: ${getDamageColor(ship.health, ship.maxHealth)};">üîß Repair (${inventory.nanobotRepair && inventory.nanobotRepair.owned > 0 ? 'Use Kit' : 'Buy Kit'})</button>` : ''}
                                ${ship.buildTime > Date.now() ? `<button onclick="showSpeedUpBuildAd()" style="background: #ffaa00;">Speed Up</button>` : ''}
                                ${!ship.destroyed && ship.health >= ship.maxHealth && ship.buildTime <= Date.now() ? `<button onclick="selectShip(${shipId})" ${player.currentShip == shipId ? 'disabled' : ''}>${player.currentShip == shipId ? 'CURRENT' : 'SELECT'}</button>` : ''}
                            </div>
                        </div>
                    `;
                    shipyardList.appendChild(shipDiv);
                }
            }
            
            // Update powerup list
            const powerupList = document.getElementById('powerupList');
            powerupList.innerHTML = '';
            
            for (let powerupType in powerupsAvailable) {
                const powerup = powerupsAvailable[powerupType];
                const powerupDiv = document.createElement('div');
                powerupDiv.className = 'shop-item';
                powerupDiv.innerHTML = `
                    <span>${powerup.name}</span>
                    <button onclick="buyPowerup('${powerupType}')">Buy (${powerup.price} coins)</button>
                `;
                powerupList.appendChild(powerupDiv);
            }
            
            // Update inventory list
            const inventoryList = document.getElementById('inventoryList');
            inventoryList.innerHTML = '';
            
            // Display owned ships
            for (let shipId in ships) {
                const ship = ships[shipId];
                if (ship.owned) {
                    const inventoryDiv = document.createElement('div');
                    inventoryDiv.className = 'shop-item';
                    inventoryDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div>
                                <span style="font-weight: bold;">üöÄ ${ship.name}</span>
                                <div style="color: ${ship.destroyed ? '#ff4444' : ship.health < ship.maxHealth ? getDamageColor(ship.health, ship.maxHealth) : '#00ff00'}; font-size: 0.9em; margin-top: 2px;">
                                    ${ship.destroyed ? 'üí• DESTROYED - Buy New Ship' : ship.health < ship.maxHealth ? `‚ö†Ô∏è ${getDamageLevel(ship.health, ship.maxHealth)} - ${Math.floor((ship.health/ship.maxHealth)*100)}% Health` : '‚úÖ Fully Functional'}
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <button onclick="selectShip(${shipId})" ${player.currentShip == shipId ? 'disabled' : ''}>
                                    ${player.currentShip == shipId ? 'CURRENT' : 'SELECT'}
                                </button>
                            </div>
                        </div>
                    `;
                    inventoryList.appendChild(inventoryDiv);
                }
            }
            
            // Display powerup inventory with USE buttons (only purchased items)
            let hasItems = false;
            for (let itemType in inventory) {
                const item = inventory[itemType];
                if (item.owned > 0) {
                    hasItems = true;
                    const inventoryDiv = document.createElement('div');
                    inventoryDiv.className = 'shop-item';
                    
                    // Get display name and icon
                    const displayNames = {
                        droneAlly: '‚ö° Drone Ally',
                        shield: 'üõ°Ô∏è Shield',
                        speed: 'üöÄ Speed Boost',
                        damage: '‚öîÔ∏è Damage Boost',
                        rapidFire: 'üî• Rapid Fire',
                        multipleShots: 'üéØ Multiple Shots',
                        magnet: 'üß≤ Magnet',
                        nanobotRepair: 'üîß Nanobot Repair',
                        piercingLaser: 'üí• Piercing Laser',
                        coinBoost: 'üí∞ Coin Boost'
                    };
                    
                    const displayName = displayNames[itemType] || itemType;
                    const canUse = item.owned > 0 && (!activePowerupCounts[itemType] || activePowerupCounts[itemType] < item.maxActive);
                    
                    inventoryDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div>
                                <span style="font-weight: bold;">${displayName}</span>
                                <div style="color: #00ffff; font-size: 0.9em; margin-top: 2px;">
                                    Owned: ${item.owned} | Active: ${activePowerupCounts[itemType] || 0}/${item.maxActive}
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <button onclick="showQuantitySelector('${itemType}', '${displayName}')" 
                                        ${canUse ? '' : 'disabled'} 
                                        style="background: ${canUse ? 'linear-gradient(45deg, #00ff00, #008000)' : 'linear-gradient(45deg, #666, #444)'}; 
                                               color: white; 
                                               border: none; 
                                               padding: 8px 16px; 
                                               border-radius: 5px; 
                                               cursor: ${canUse ? 'pointer' : 'not-allowed'}; 
                                               font-weight: bold;">
                                    ${canUse ? 'USE' : 'MAX'}
                                </button>
                            </div>
                        </div>
                    `;
                    inventoryList.appendChild(inventoryDiv);
                }
            }
            
            // Show message if inventory is empty
            if (!hasItems) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'shop-item';
                emptyDiv.innerHTML = `
                    <div style="text-align: center; color: #888; padding: 20px;">
                        <p>üì¶ Your inventory is empty</p>
                        <p style="font-size: 0.9em; margin-top: 10px;">Purchase powerups from the shop to add them here!</p>
                    </div>
                `;
                inventoryList.appendChild(emptyDiv);
            }
            
            // Note: Premium weapons and powerups are handled separately in their own shop tabs
        }
        
                         function buyShip(shipId) {
            const ship = ships[shipId];
            if (coins >= ship.price) {
                coins -= ship.price;
                ship.owned = true;
                ship.destroyed = false;
                
                // Set build time for higher level ships
                if (ship.level > 1) {
                    ship.buildTime = Date.now() + ship.baseBuildTime;
                    ship.currentBuildTime = ship.baseBuildTime;
                    shipsUnderConstruction[shipId] = ship.buildTime;
                }
                
                // Update player stats
                playerStats.shipsOwned++;
                updatePlayerStats();
                
                updateShopDisplay();
                updateHUD();
                
                if (ship.level > 1) {
                    showRewardMessage(`üöÄ ${ship.name} construction started! Build time: ${ship.baseBuildTime/1000}s`);
                } else {
                    showRewardMessage(`üöÄ ${ship.name} purchased!`);
                }
            } else {
                alert('Not enough coins!');
            }
        }
        
        function repairShip(shipId) {
            const ship = ships[shipId];
            
            // Check if ship is destroyed (cannot be repaired)
            if (ship.destroyed) {
                alert('This ship has been completely destroyed! You must buy a new ship to replace it.');
                return;
            }
            
            // Check if ship needs repair (health < maxHealth)
            if (ship.health >= ship.maxHealth) {
                alert('This ship is already at full health!');
                return;
            }
            
            // Check if player has nanobot repair kits in inventory
            if (inventory.nanobotRepair && inventory.nanobotRepair.owned > 0) {
                // Use nanobot repair kit
                inventory.nanobotRepair.owned--;
                ship.health = ship.maxHealth; // Restore full health
                
                updateShopDisplay();
                updateHUD();
                showRewardMessage(`üîß ${ship.name} repaired with nanobot repair kit!`);
                
                // Update active powerup count
                if (!activePowerupCounts.nanobotRepair) {
                    activePowerupCounts.nanobotRepair = 0;
                }
                activePowerupCounts.nanobotRepair++;
                
            } else {
                // No repair kits available - offer to buy one
                const repairCost = 100; // Cost to buy a repair kit
                if (coins >= repairCost) {
                    if (confirm(`No nanobot repair kits available. Buy one for ${repairCost} coins to repair ${ship.name}?`)) {
                        coins -= repairCost;
                        
                        // Add repair kit to inventory
                        if (!inventory.nanobotRepair) {
                            inventory.nanobotRepair = { owned: 0, maxActive: 10 };
                        }
                        inventory.nanobotRepair.owned++;
                        
                        // Use it immediately
                        inventory.nanobotRepair.owned--;
                        ship.destroyed = false;
                        ship.health = ship.maxHealth;
                        
                        updateShopDisplay();
                        updateHUD();
                        showRewardMessage(`üîß ${ship.name} repaired! (Bought and used repair kit)`);
                    }
                } else {
                    // Player can't afford repair - offer alternatives
                    const options = [
                        'Watch Ad for 50 coins',
                        'Use Level 1 ship (always available)',
                        'Try to earn coins in current ship'
                    ];
                    
                    const choice = prompt(`No nanobot repair kits available and not enough coins (${repairCost} needed)!\n\nChoose an option:\n1. Watch sponsor ad (100 coins)\n2. Watch regular ad (50 coins)\n3. Switch to Level 1 ship\n\nEnter 1, 2, or 3:`);
                    
                    if (choice === '1') {
                        // Watch sponsor ad for more coins
                        showAdModal('sponsor', () => {
                            coins += 100;
                            updateHUD();
                            showRewardMessage('üí∞ Earned 100 coins from sponsor ad!');
                            
                            // Try to repair again
                            setTimeout(() => repairShip(shipId), 500);
                        });
                    } else if (choice === '2') {
                        // Watch regular ad for coins
                        showAdModal('coins', () => {
                            coins += 50;
                            updateHUD();
                            showRewardMessage('üí∞ Earned 50 coins from ad!');
                            
                            // Try to repair again
                            setTimeout(() => repairShip(shipId), 500);
                        });
                    } else if (choice === '3') {
                        // Switch to Level 1 ship
                        if (ships[1] && !ships[1].destroyed) {
                            selectShip(1);
                            showRewardMessage('üöÄ Switched to Level 1 ship!');
                        } else {
                            // Even Level 1 ship is damaged - force repair it for free
                            ships[1].destroyed = false;
                            ships[1].health = ships[1].maxHealth;
                            selectShip(1);
                            showRewardMessage('üîß Level 1 ship auto-repaired! (Emergency backup)');
                        }
                    } else {
                        // Invalid choice - default to regular ad
                        showAdModal('coins', () => {
                            coins += 50;
                            updateHUD();
                            showRewardMessage('üí∞ Earned 50 coins from ad!');
                            
                            // Try to repair again
                            setTimeout(() => repairShip(shipId), 500);
                        });
                    }
                }
            }
        }
        
        function buyPowerup(powerupType) {
            const powerup = powerupsAvailable[powerupType];
            if (coins >= powerup.price) {
                coins -= powerup.price;
                
                // Add to inventory (main inventory object)
                if (!inventory[powerupType]) {
                    inventory[powerupType] = { owned: 0, maxActive: 5 };
                }
                inventory[powerupType].owned++;
                
                // Initialize active count if not exists
                if (!activePowerupCounts[powerupType]) {
                    activePowerupCounts[powerupType] = 0;
                }
                
                // Add to receipt
                addToReceipt(powerup, 'coins', powerup.price);
                
                updateShopDisplay();
                updateHUD();
                
                // Show receipt
                showPurchaseReceipt();
                
                console.log(`üì¶ Purchased ${powerup.name} - now own ${inventory[powerupType].owned}`);
            } else {
                alert('Not enough coins!');
            }
        }
        
        function buyPremiumWeapon(weaponType) {
            const weapon = premiumWeapons[weaponType];
            if (revCoins >= weapon.price) {
                revCoins -= weapon.price;
                
                // Add to inventory
                addToInventory('premiumWeapons', weaponType, weapon);
                
                // Add to receipt
                addToReceipt(weapon, 'revCoins', weapon.price);
                
                // Add to active weapons
                activePremiumWeapons[weaponType] = {
                    lastUsed: 0,
                    cooldown: weapon.cooldown
                };
                
                // Update player stats
                playerStats.weaponsOwned++;
                updatePlayerStats();
                
                updateHUD();
                updatePremiumShopDisplay();
                updateShopDisplay(); // Update inventory display
                
                // Show receipt
                showPurchaseReceipt();
            } else {
                alert('Not enough RevCoins! Watch ads to earn RevCoins.');
            }
        }
        
        function buyPremiumPowerup(powerupType) {
            const powerup = premiumPowerups[powerupType];
            if (revCoins >= powerup.price) {
                revCoins -= powerup.price;
                
                // Add to inventory
                addToInventory('premiumPowerups', powerupType, powerup);
                
                // Add to receipt
                addToReceipt(powerup, 'revCoins', powerup.price);
                
                // Activate the powerup
                activatePremiumPowerup(powerupType);
                
                updateHUD();
                updatePremiumShopDisplay();
                updateShopDisplay(); // Update inventory display
                
                // Show receipt
                showPurchaseReceipt();
            } else {
                alert('Not enough RevCoins! Watch ads to earn RevCoins.');
            }
        }
        
        function activatePremiumPowerup(type) {
            const powerup = premiumPowerups[type];
            const currentTime = Date.now();
            
            switch(type) {
                case 'megaShield':
                    activePowerups.shield.charges = Math.min(activePowerups.shield.charges + powerup.charges, activePowerups.shield.maxCharges);
                    activePowerups.shield.maxCharges = Math.max(activePowerups.shield.maxCharges, powerup.charges);
                    break;
                case 'hyperSpeed':
                    if (activePowerups.speed && activePowerups.speed > currentTime) {
                        activePowerups.speed += powerup.duration;
                    } else {
                        activePowerups.speed = currentTime + powerup.duration;
                    }
                    player.speed = 4 * powerup.multiplier;
                    break;
                case 'ultimateDamage':
                    if (activePowerups.damage && activePowerups.damage > currentTime) {
                        activePowerups.damage += powerup.duration;
                    } else {
                        activePowerups.damage = currentTime + powerup.duration;
                    }
                    break;
                case 'infiniteRapidFire':
                    if (activePowerups.rapidFire && activePowerups.rapidFire > currentTime) {
                        activePowerups.rapidFire += powerup.duration;
                    } else {
                        activePowerups.rapidFire = currentTime + powerup.duration;
                    }
                    break;
                case 'superMagnet':
                    if (activePowerups.magnet.active && activePowerups.magnet.endTime > currentTime) {
                        activePowerups.magnet.endTime += powerup.duration;
                        activePowerups.magnet.pullRadius = Math.max(activePowerups.magnet.pullRadius, powerup.pullRadius);
                        activePowerups.magnet.pullStrength = Math.max(activePowerups.magnet.pullStrength, powerup.pullStrength);
                    } else {
                        activePowerups.magnet.active = true;
                        activePowerups.magnet.endTime = currentTime + powerup.duration;
                        activePowerups.magnet.pullRadius = powerup.pullRadius;
                        activePowerups.magnet.pullStrength = powerup.pullStrength;
                    }
                    break;
            }
            
            createPowerEffect('premiumActivate', player.x + player.width / 2, player.y + player.height / 2);
            showPowerupMessage(type);
        }
        
        // Premium Shop Functions
        function openPremiumShop() {
            document.getElementById('premiumShop').style.display = 'flex';
            updatePremiumShopDisplay();
        }
        
        function closePremiumShop() {
            document.getElementById('premiumShop').style.display = 'none';
        }
        
        function goBackFromShop() {
            document.getElementById('shop').style.display = 'none';
            // Only resume if we were actually playing (not from level complete)
            if (gameRunning && !levelCompleteMenuShouldBeShown) {
                gamePaused = false;
                gameLoop();
            } else if (levelCompleteMenuShouldBeShown) {
                document.getElementById('levelComplete').style.display = 'block';
            }
        }
        
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`premium${tabName.charAt(0).toUpperCase() + tabName.slice(1)}Tab`).classList.add('active');
        }
        
        function switchShopTab(tabName) {
            // Remove active class from all shop tabs and content
            document.querySelectorAll('.shop-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.shop-tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}Tab`).classList.add('active');
        }
        
        function switchWeaponTab(tabName) {
            // Remove active class from all weapon tabs and content
            document.querySelectorAll('.weapon-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.weapon-tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}WeaponsTab`).classList.add('active');
        }
        
        function openWeaponShop() {
            document.getElementById('weaponShop').style.display = 'flex';
            updateWeaponShopDisplay();
        }
        
        function closeWeaponShop() {
            document.getElementById('weaponShop').style.display = 'none';
        }
        
        function updateWeaponShopDisplay() {
            // Update coins display
            document.getElementById('weaponShopCoins').textContent = coins;
            
            // Populate regular weapons (ship-based)
            const regularWeaponsList = document.getElementById('regularWeaponsList');
            regularWeaponsList.innerHTML = '';
            
            for (let shipId in ships) {
                const ship = ships[shipId];
                if (ship.owned && !ship.destroyed) {
                    const weaponDiv = document.createElement('div');
                    weaponDiv.className = 'weapon-item';
                    
                    weaponDiv.innerHTML = `
                        <div class="weapon-item-header">
                            <div class="weapon-item-name">${ship.name} Weapons</div>
                            <div class="weapon-item-price">OWNED</div>
                        </div>
                        <div class="weapon-item-description">Standard weapons for ${ship.name}</div>
                        <div class="weapon-item-stats">
                            <div class="weapon-stat">Damage: ${ship.damage}</div>
                            <div class="weapon-stat">Fire Rate: ${ship.fireRate}ms</div>
                            <div class="weapon-stat">Speed: ${ship.speed}</div>
                            <div class="weapon-stat">Health: ${ship.health}</div>
                        </div>
                        <button class="weapon-buy-btn" onclick="selectShip(${shipId})" 
                                ${currentShip == shipId ? 'disabled' : ''}>
                            ${currentShip == shipId ? 'CURRENT SHIP' : 'SELECT SHIP'}
                        </button>
                    `;
                    
                    regularWeaponsList.appendChild(weaponDiv);
                }
            }
            
            // Populate premium weapons
            const premiumWeaponsList = document.getElementById('premiumWeaponsList');
            premiumWeaponsList.innerHTML = '';
            
            for (let weaponId in premiumWeapons) {
                const weapon = premiumWeapons[weaponId];
                const weaponDiv = document.createElement('div');
                weaponDiv.className = 'weapon-item';
                
                const isOwned = activePremiumWeapons[weaponId];
                const canAfford = revCoins >= weapon.price;
                
                weaponDiv.innerHTML = `
                    <div class="weapon-item-header">
                        <div class="weapon-item-name">${weapon.name}</div>
                        <div class="weapon-item-price">${weapon.price} üíé</div>
                    </div>
                    <div class="weapon-item-description">${weapon.description}</div>
                    <div class="weapon-item-stats">
                        <div class="weapon-stat">Damage: ${weapon.damage}</div>
                        <div class="weapon-stat">Cooldown: ${weapon.cooldown/1000}s</div>
                        ${weapon.radius ? `<div class="weapon-stat">Radius: ${weapon.radius}</div>` : ''}
                        ${weapon.pierce ? `<div class="weapon-stat">Piercing</div>` : ''}
                    </div>
                    <button class="weapon-buy-btn" onclick="buyPremiumWeapon('${weaponId}')" 
                            ${isOwned ? 'disabled' : ''} ${!canAfford ? 'disabled' : ''}>
                        ${isOwned ? 'OWNED' : canAfford ? 'PURCHASE' : 'NOT ENOUGH REVCOINS'}
                    </button>
                `;
                
                premiumWeaponsList.appendChild(weaponDiv);
            }
        }
        
        function selectShip(shipId) {
            const ship = ships[shipId];
            
            // Check if ship is owned and not destroyed
            if (!ship.owned) {
                alert('You need to purchase this ship first!');
                return;
            }
            
            if (ship.destroyed) {
                const choice = confirm(`This ship is damaged! You can:\n\n‚Ä¢ Repair it with nanobot kit (recommended)\n‚Ä¢ Use it damaged (reduced performance)\n‚Ä¢ Switch to another ship\n\nClick OK to try to repair, Cancel to use damaged ship.`);
                
                if (choice) {
                    // Try to repair
                    repairShip(shipId);
                    return;
                } else {
                    // Use damaged ship with penalties
                    console.log(`‚ö†Ô∏è Using damaged ship: ${ship.name}`);
                    showRewardMessage(`‚ö†Ô∏è Using damaged ship - reduced performance!`);
                }
            }
            
            // Check if ship is still under construction
            if (ship.buildTime > Date.now()) {
                const remainingTime = Math.ceil((ship.buildTime - Date.now()) / 1000);
                alert(`Ship is still under construction! ${remainingTime} seconds remaining.`);
                return;
            }
            
            currentShip = shipId;
            player.currentShip = shipId; // Update player's current ship
            
            // Update player stats based on selected ship
            if (ship.destroyed) {
                // Damaged ship penalties
                player.damage = Math.floor(ship.damage * 0.5); // 50% damage reduction
                player.fireRate = ship.fireRate * 1.5; // 50% slower firing
                player.speed = ship.speed * 0.7; // 30% slower movement
                player.maxHealth = Math.floor(ship.maxHealth * 0.6); // 40% less health
                player.health = Math.min(health, player.maxHealth); // Don't exceed new max
                
                console.log(`‚ö†Ô∏è Using damaged ship - Damage: ${player.damage}, Fire Rate: ${player.fireRate}, Speed: ${player.speed}, Health: ${player.health}/${player.maxHealth}`);
            } else {
                // Normal ship stats
                player.damage = ship.damage;
                player.fireRate = ship.fireRate;
                player.speed = ship.speed;
                player.maxHealth = ship.maxHealth;
                player.health = ship.health;
            }
            
            updateWeaponShopDisplay();
            updateShopDisplay(); // Update shipyard display to show current ship
            updateHUD();
            
            showRewardMessage(`üöÄ ${ship.name} selected!`);
        }
        
        function updatePremiumShopDisplay() {
            // Update RevCoins display
            document.getElementById('premiumRevCoins').textContent = revCoins;
            
            // Populate premium weapons
            const weaponsList = document.getElementById('premiumShopWeaponsList');
            weaponsList.innerHTML = '';
            
            for (let weaponId in premiumWeapons) {
                const weapon = premiumWeapons[weaponId];
                const weaponDiv = document.createElement('div');
                weaponDiv.className = 'premium-item';
                
                const isOwned = activePremiumWeapons[weaponId];
                const canAfford = revCoins >= weapon.price;
                
                weaponDiv.innerHTML = `
                    <div class="premium-item-header">
                        <div class="premium-item-name">${weapon.name}</div>
                        <div class="premium-item-price">${weapon.price} üíé</div>
                    </div>
                    <div class="premium-item-description">${weapon.description}</div>
                    <div class="premium-item-stats">
                        <div class="premium-stat">Damage: ${weapon.damage}</div>
                        <div class="premium-stat">Cooldown: ${weapon.cooldown/1000}s</div>
                        ${weapon.radius ? `<div class="premium-stat">Radius: ${weapon.radius}</div>` : ''}
                        ${weapon.pierce ? `<div class="premium-stat">Piercing</div>` : ''}
                    </div>
                    <button class="premium-buy-btn" onclick="buyPremiumWeapon('${weaponId}')" 
                            ${isOwned ? 'disabled' : ''} ${!canAfford ? 'disabled' : ''}>
                        ${isOwned ? 'OWNED' : canAfford ? 'PURCHASE' : 'NOT ENOUGH REVCOINS'}
                    </button>
                `;
                
                weaponsList.appendChild(weaponDiv);
            }
            
            // Populate premium powerups
            const powerupsList = document.getElementById('premiumPowerupsList');
            powerupsList.innerHTML = '';
            
            for (let powerupId in premiumPowerups) {
                const powerup = premiumPowerups[powerupId];
                const powerupDiv = document.createElement('div');
                powerupDiv.className = 'premium-item';
                
                const canAfford = revCoins >= powerup.price;
                
                powerupDiv.innerHTML = `
                    <div class="premium-item-header">
                        <div class="premium-item-name">${powerup.name}</div>
                        <div class="premium-item-price">${powerup.price} üíé</div>
                    </div>
                    <div class="premium-item-description">${powerup.description}</div>
                    <div class="premium-item-stats">
                        <div class="premium-stat">Duration: ${powerup.duration/1000}s</div>
                        ${powerup.charges ? `<div class="premium-stat">Charges: ${powerup.charges}</div>` : ''}
                        ${powerup.multiplier ? `<div class="premium-stat">Multiplier: ${powerup.multiplier}x</div>` : ''}
                        ${powerup.pullRadius ? `<div class="premium-stat">Radius: ${powerup.pullRadius}</div>` : ''}
                    </div>
                    <button class="premium-buy-btn" onclick="buyPremiumPowerup('${powerupId}')" 
                            ${!canAfford ? 'disabled' : ''}>
                        ${canAfford ? 'PURCHASE & ACTIVATE' : 'NOT ENOUGH REVCOINS'}
                    </button>
                `;
                
                powerupsList.appendChild(powerupDiv);
            }
        }
        
        function restartGame() {
            // Keep everything - just restore health and clear current wave enemies
            health = 100;
            // Keep current wave, score, coins, weapons, powerups, etc.
            
            // Only reset wave progress for current wave
            enemiesKilledThisWave = 0;
            coinsEarnedThisWave = 0;
            loyaltyEarnedThisWave = 0;
            
            // Clear only current wave enemies and bullets
            bullets = [];
            enemies = [];
            powerups = [];
            explosions = [];
            seekingMissiles = [];
            missileExplosions = [];
            
            // Reset player position
            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height - player.height - 50;
            
            // Keep all active powerups and weapons - don't reset them
            // activePowerups and activePremiumWeapons stay as they are
            
            // Reset boss state for current wave
            bossActive = false;
            currentBoss = null;
            bossWarningShown = false;
            
            // Hide menus
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('levelComplete').style.display = 'none';
            document.getElementById('shop').style.display = 'none';
            
            // Start game
            gameRunning = true;
            gamePaused = false;
            levelCompleteMenuShouldBeShown = false;

            // Restart the game loop after resetting state
            gameLoop();
        }

        // ===== START GAME =====
         window.addEventListener('load', init);

        // ===== AD SYSTEM =====
        function showAdBonus() {
            if (adWatchedThisWave) {
                alert('You have already watched an ad for this wave!');
                return;
            }
            
            const adDialog = document.createElement('div');
            adDialog.className = 'ad-dialog';
            adDialog.innerHTML = `
                <div class="ad-content">
                    <h3>üé¨ Watch Ad for Bonus Rewards</h3>
                    <p>Double your wave earnings!</p>
                    <div class="ad-rewards">
                        <div>üí∞ Coins: ${coinsEarnedThisWave} ‚Üí ${coinsEarnedThisWave * 2}</div>
                        <div>üíé Loyalty: $${loyaltyEarnedThisWave.toFixed(6)} ‚Üí $${(loyaltyEarnedThisWave * 2).toFixed(6)}</div>
                    </div>
                    <div class="ad-buttons">
                        <button onclick="watchAd()" class="ad-watch-btn">Watch Ad</button>
                        <button onclick="closeAdDialog()" class="ad-skip-btn">Skip</button>
                    </div>
                </div>
            `;
            document.body.appendChild(adDialog);
        }
        
        function watchAd() {
            // Simulate ad watching
            setTimeout(() => {
                // Double the wave earnings
                coins += coinsEarnedThisWave;
                loyalty += loyaltyEarnedThisWave;
                wallet += loyaltyEarnedThisWave;
                
                adWatchedThisWave = true;
                adBonusAvailable = false;
                
                closeAdDialog();
                updateHUD();
                
                alert(`üéâ Ad completed! Bonus rewards added!\nüí∞ +${coinsEarnedThisWave} coins\nüíé +$${loyaltyEarnedThisWave.toFixed(6)} loyalty`);
            }, 2000); // Simulate 2 second ad
        }
        
        function closeAdDialog() {
            const adDialog = document.querySelector('.ad-dialog');
            if (adDialog) {
                adDialog.remove();
            }
        }
        
        // ===== WITHDRAWAL SYSTEM =====
        function showWithdrawalDialog() {
            if (wallet < 5.00) {
                alert('‚ùå Minimum withdrawal amount is $5.00\nCurrent wallet: $' + wallet.toFixed(4));
                return;
            }
            
            const withdrawalDialog = document.createElement('div');
            withdrawalDialog.className = 'withdrawal-dialog';
            withdrawalDialog.innerHTML = `
                <div class="withdrawal-content">
                    <h3>üí≥ Withdraw Funds</h3>
                    <div class="wallet-info">
                        <div>üí∞ Available: $${wallet.toFixed(4)}</div>
                        <div>üíé Total Loyalty: $${loyalty.toFixed(6)}</div>
                    </div>
                    <div class="withdrawal-input">
                        <label>Amount to withdraw:</label>
                        <input type="number" id="withdrawalAmount" min="5.00" max="${wallet}" step="0.01" value="${Math.min(wallet, 50.00)}" />
                    </div>
                    <div class="withdrawal-buttons">
                        <button onclick="processWithdrawal()" class="withdraw-btn">Withdraw</button>
                        <button onclick="closeWithdrawalDialog()" class="cancel-btn">Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(withdrawalDialog);
        }
        
        function processWithdrawal() {
            const amount = parseFloat(document.getElementById('withdrawalAmount').value);
            
            if (amount < 5.00) {
                alert('‚ùå Minimum withdrawal amount is $5.00');
                return;
            }
            
            if (amount > wallet) {
                alert('‚ùå Insufficient funds in wallet');
                return;
            }
            
            wallet -= amount;
            updateHUD();
            closeWithdrawalDialog();
            
            alert(`‚úÖ Withdrawal processed!\nüí∞ Amount: $${amount.toFixed(4)}\nüí≥ Remaining wallet: $${wallet.toFixed(4)}`);
        }
        
        function closeWithdrawalDialog() {
            const withdrawalDialog = document.querySelector('.withdrawal-dialog');
            if (withdrawalDialog) {
                withdrawalDialog.remove();
            }
        }
    </script>
</body>
</html>